   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .fpu softvfp
   4              	 .eabi_attribute 20,1
   5              	 .eabi_attribute 21,1
   6              	 .eabi_attribute 23,3
   7              	 .eabi_attribute 24,1
   8              	 .eabi_attribute 25,1
   9              	 .eabi_attribute 26,1
  10              	 .eabi_attribute 30,6
  11              	 .eabi_attribute 34,1
  12              	 .eabi_attribute 18,4
  13              	 .thumb
  14              	 .file "arm_mat_inverse_f32.c"
  15              	 .text
  16              	.Ltext0:
  17              	 .cfi_sections .debug_frame
  18              	 .global __aeabi_fcmpgt
  19              	 .global __aeabi_fcmpeq
  20              	 .global __aeabi_fdiv
  21              	 .global __aeabi_fmul
  22              	 .global __aeabi_fsub
  23              	 .section .text.arm_mat_inverse_f32,"ax",%progbits
  24              	 .align 2
  25              	 .global arm_mat_inverse_f32
  26              	 .thumb
  27              	 .thumb_func
  29              	arm_mat_inverse_f32:
  30              	.LFB139:
  31              	 .file 1 "../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c"
   1:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /* ----------------------------------------------------------------------    
   2:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * Copyright (C) 2010-2014 ARM Limited. All rights reserved.    
   3:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *    
   4:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * $Date:        12. March 2014
   5:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * $Revision: 	V1.4.4
   6:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *    
   7:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * Project: 	    CMSIS DSP Library    
   8:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * Title:	    arm_mat_inverse_f32.c    
   9:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *    
  10:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * Description:	Floating-point matrix inverse.    
  11:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *    
  12:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * Target Processor: Cortex-M4/Cortex-M3/Cortex-M0
  13:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *  
  14:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * Redistribution and use in source and binary forms, with or without 
  15:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * modification, are permitted provided that the following conditions
  16:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * are met:
  17:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *   - Redistributions of source code must retain the above copyright
  18:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *     notice, this list of conditions and the following disclaimer.
  19:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *   - Redistributions in binary form must reproduce the above copyright
  20:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *     notice, this list of conditions and the following disclaimer in
  21:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *     the documentation and/or other materials provided with the 
  22:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *     distribution.
  23:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *   - Neither the name of ARM LIMITED nor the names of its contributors
  24:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *     may be used to endorse or promote products derived from this
  25:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *     software without specific prior written permission.
  26:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** *
  27:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  28:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  29:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  30:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
  31:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  32:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  33:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  34:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  35:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  36:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * POSSIBILITY OF SUCH DAMAGE.    
  39:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** * -------------------------------------------------------------------- */
  40:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  41:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #include "CMSIS_DSP/cmsis_dsp.h"
  42:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  43:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**    
  44:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @ingroup groupMatrix    
  45:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  46:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  47:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**    
  48:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @defgroup MatrixInv Matrix Inverse    
  49:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *    
  50:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Computes the inverse of a matrix.    
  51:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *    
  52:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The inverse is defined only if the input matrix is square and non-singular (the determinant    
  53:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * is non-zero). The function checks that the input and output matrices are square and of the    
  54:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * same size.    
  55:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *    
  56:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Matrix inversion is numerically sensitive and the CMSIS DSP library only supports matrix    
  57:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * inversion of floating-point matrices.    
  58:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *    
  59:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * \par Algorithm    
  60:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The Gauss-Jordan method is used to find the inverse.    
  61:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The algorithm performs a sequence of elementary row-operations until it    
  62:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * reduces the input matrix to an identity matrix. Applying the same sequence    
  63:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * of elementary row-operations to an identity matrix yields the inverse matrix.    
  64:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * If the input matrix is singular, then the algorithm terminates and returns error status    
  65:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SINGULAR</code>.    
  66:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * \image html MatrixInverse.gif "Matrix Inverse of a 3 x 3 matrix using Gauss-Jordan Method"    
  67:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  68:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  69:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**    
  70:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @addtogroup MatrixInv    
  71:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @{    
  72:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  73:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  74:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**    
  75:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @brief Floating-point matrix inverse.    
  76:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @param[in]       *pSrc points to input matrix structure    
  77:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @param[out]      *pDst points to output matrix structure    
  78:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @return     		The function returns    
  79:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SIZE_MISMATCH</code> if the input matrix is not square or if the size    
  80:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * of the output matrix does not match the size of the input matrix.    
  81:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * If the input matrix is found to be singular (non-invertible), then the function returns    
  82:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SINGULAR</code>.  Otherwise, the function returns <code>ARM_MATH_SUCCESS</code>. 
  83:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  84:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  85:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** arm_status arm_mat_inverse_f32(
  86:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   const arm_matrix_instance_f32 * pSrc,
  87:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_matrix_instance_f32 * pDst)
  88:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** {
  32              	 .loc 1 88 0
  33              	 .cfi_startproc
  34              	 
  35              	 
  36 0000 90B5     	 push {r4,r7,lr}
  37              	.LCFI0:
  38              	 .cfi_def_cfa_offset 12
  39              	 .cfi_offset 4,-12
  40              	 .cfi_offset 7,-8
  41              	 .cfi_offset 14,-4
  42 0002 9BB0     	 sub sp,sp,#108
  43              	.LCFI1:
  44              	 .cfi_def_cfa_offset 120
  45 0004 00AF     	 add r7,sp,#0
  46              	.LCFI2:
  47              	 .cfi_def_cfa_register 7
  48 0006 7860     	 str r0,[r7,#4]
  49 0008 3960     	 str r1,[r7]
  89:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
  50              	 .loc 1 89 0
  51 000a 7B68     	 ldr r3,[r7,#4]
  52 000c 5B68     	 ldr r3,[r3,#4]
  53 000e 7B66     	 str r3,[r7,#100]
  90:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
  54              	 .loc 1 90 0
  55 0010 3B68     	 ldr r3,[r7]
  56 0012 5B68     	 ldr r3,[r3,#4]
  57 0014 3B62     	 str r3,[r7,#32]
  91:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
  92:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
  93:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data 
  94:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
  58              	 .loc 1 94 0
  59 0016 7B68     	 ldr r3,[r7,#4]
  60 0018 1B88     	 ldrh r3,[r3]
  61 001a FB61     	 str r3,[r7,#28]
  95:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
  62              	 .loc 1 95 0
  63 001c 7B68     	 ldr r3,[r7,#4]
  64 001e 5B88     	 ldrh r3,[r3,#2]
  65 0020 BB61     	 str r3,[r7,#24]
  96:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  97:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #ifndef ARM_MATH_CM0_FAMILY
  98:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t maxC;                                /* maximum value in the column */
  99:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 100:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
 101:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 102:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
  66              	 .loc 1 102 0
  67 0022 4FF00003 	 mov r3,#0
  68 0026 7B64     	 str r3,[r7,#68]
 103:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
  69              	 .loc 1 103 0
  70 0028 0023     	 movs r3,#0
  71 002a BB63     	 str r3,[r7,#56]
 104:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
 105:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 106:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
 107:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 108:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 109:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
 110:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
  72              	 .loc 1 110 0
  73 002c 7B68     	 ldr r3,[r7,#4]
  74 002e 1A88     	 ldrh r2,[r3]
  75 0030 7B68     	 ldr r3,[r7,#4]
  76 0032 5B88     	 ldrh r3,[r3,#2]
  77 0034 9A42     	 cmp r2,r3
  78 0036 0BD1     	 bne .L2
  79              	 .loc 1 110 0 is_stmt 0 discriminator 1
  80 0038 3B68     	 ldr r3,[r7]
  81 003a 1A88     	 ldrh r2,[r3]
  82 003c 3B68     	 ldr r3,[r7]
  83 003e 5B88     	 ldrh r3,[r3,#2]
  84 0040 9A42     	 cmp r2,r3
  85 0042 05D1     	 bne .L2
 111:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
  86              	 .loc 1 111 0 is_stmt 1
  87 0044 7B68     	 ldr r3,[r7,#4]
  88 0046 1A88     	 ldrh r2,[r3]
  89 0048 3B68     	 ldr r3,[r7]
  90 004a 1B88     	 ldrh r3,[r3]
  91 004c 9A42     	 cmp r2,r3
  92 004e 03D0     	 beq .L3
  93              	.L2:
 112:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 113:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
 114:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
  94              	 .loc 1 114 0
  95 0050 FD23     	 movs r3,#253
  96 0052 87F82730 	 strb r3,[r7,#39]
  97 0056 ECE1     	 b .L4
  98              	.L3:
 115:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 116:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   else
 117:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
 118:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 119:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 120:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 121:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
 122:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 * Matrix Inverse can be solved using elementary row operations.    
 123:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 124:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	Gauss-Jordan Method:    
 125:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 126:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an    
 127:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *        augmented matrix as follows:    
 128:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *				        _ 	      	       _         _	       _    
 129:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |    
 130:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |           |        |   =   |           |    
 131:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|    
 132:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 133:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
 134:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 135:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		3. Begin with the first row. Let i = 1.    
 136:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 137:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    4. Check to see if the pivot for column i is the greatest of the column.    
 138:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The pivot is the element of the main diagonal that is on the current row.    
 139:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   For instance, if working with row i, then the pivot element is aii.    
 140:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
 141:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   below it that does contain the most significant value in column i. If the most
 142:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
 143:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The most significant value of the column is the absolute maximum.
 144:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 145:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    5. Divide every element of row i by the pivot.    
 146:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 147:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    6. For every row below and  row i, replace that row with the sum of that row and    
 148:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   a multiple of row i so that each new element in column i below row i is zero.    
 149:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 150:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros    
 151:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   for every element below and above the main diagonal.    
 152:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *    
 153:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).    
 154:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).    
 155:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *------------------------------------------------------------------------------------------------
 156:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 157:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
 158:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
  99              	 .loc 1 158 0
 100 0058 3B6A     	 ldr r3,[r7,#32]
 101 005a BB65     	 str r3,[r7,#88]
 159:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 160:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
 161:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
 102              	 .loc 1 161 0
 103 005c FB69     	 ldr r3,[r7,#28]
 104 005e FB63     	 str r3,[r7,#60]
 162:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 163:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
 164:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while(rowCnt > 0u)
 105              	 .loc 1 164 0
 106 0060 29E0     	 b .L5
 107              	.L10:
 165:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 166:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 167:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
 108              	 .loc 1 167 0
 109 0062 FA69     	 ldr r2,[r7,#28]
 110 0064 FB6B     	 ldr r3,[r7,#60]
 111 0066 D31A     	 subs r3,r2,r3
 112 0068 7B63     	 str r3,[r7,#52]
 168:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(j > 0u)
 113              	 .loc 1 168 0
 114 006a 08E0     	 b .L6
 115              	.L7:
 169:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 170:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 116              	 .loc 1 170 0
 117 006c BB6D     	 ldr r3,[r7,#88]
 118 006e 1A1D     	 adds r2,r3,#4
 119 0070 BA65     	 str r2,[r7,#88]
 120 0072 4FF00002 	 mov r2,#0
 121 0076 1A60     	 str r2,[r3]
 171:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 122              	 .loc 1 171 0
 123 0078 7B6B     	 ldr r3,[r7,#52]
 124 007a 013B     	 subs r3,r3,#1
 125 007c 7B63     	 str r3,[r7,#52]
 126              	.L6:
 168:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(j > 0u)
 127              	 .loc 1 168 0
 128 007e 7B6B     	 ldr r3,[r7,#52]
 129 0080 002B     	 cmp r3,#0
 130 0082 F3D1     	 bne .L7
 172:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 173:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 174:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
 175:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
 131              	 .loc 1 175 0
 132 0084 BB6D     	 ldr r3,[r7,#88]
 133 0086 1A1D     	 adds r2,r3,#4
 134 0088 BA65     	 str r2,[r7,#88]
 135 008a 4FF07E52 	 mov r2,#1065353216
 136 008e 1A60     	 str r2,[r3]
 176:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 177:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 178:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1u;
 137              	 .loc 1 178 0
 138 0090 FB6B     	 ldr r3,[r7,#60]
 139 0092 013B     	 subs r3,r3,#1
 140 0094 7B63     	 str r3,[r7,#52]
 179:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(j > 0u)
 141              	 .loc 1 179 0
 142 0096 08E0     	 b .L8
 143              	.L9:
 180:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 181:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 144              	 .loc 1 181 0
 145 0098 BB6D     	 ldr r3,[r7,#88]
 146 009a 1A1D     	 adds r2,r3,#4
 147 009c BA65     	 str r2,[r7,#88]
 148 009e 4FF00002 	 mov r2,#0
 149 00a2 1A60     	 str r2,[r3]
 182:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 150              	 .loc 1 182 0
 151 00a4 7B6B     	 ldr r3,[r7,#52]
 152 00a6 013B     	 subs r3,r3,#1
 153 00a8 7B63     	 str r3,[r7,#52]
 154              	.L8:
 179:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(j > 0u)
 155              	 .loc 1 179 0
 156 00aa 7B6B     	 ldr r3,[r7,#52]
 157 00ac 002B     	 cmp r3,#0
 158 00ae F3D1     	 bne .L9
 183:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 184:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 185:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 186:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
 159              	 .loc 1 186 0
 160 00b0 FB6B     	 ldr r3,[r7,#60]
 161 00b2 013B     	 subs r3,r3,#1
 162 00b4 FB63     	 str r3,[r7,#60]
 163              	.L5:
 164:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 164              	 .loc 1 164 0
 165 00b6 FB6B     	 ldr r3,[r7,#60]
 166 00b8 002B     	 cmp r3,#0
 167 00ba D2D1     	 bne .L10
 187:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 188:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 189:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.    
 190:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
 191:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
 168              	 .loc 1 191 0
 169 00bc BB69     	 ldr r3,[r7,#24]
 170 00be 3B63     	 str r3,[r7,#48]
 192:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 193:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
 194:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0u;
 171              	 .loc 1 194 0
 172 00c0 0023     	 movs r3,#0
 173 00c2 BB62     	 str r3,[r7,#40]
 195:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 196:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while(loopCnt > 0u)
 174              	 .loc 1 196 0
 175 00c4 A0E1     	 b .L11
 176              	.L56:
 197:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 198:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..    
 199:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.    
 200:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,    
 201:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
 202:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 203:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points    
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 205:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
 177              	 .loc 1 205 0
 178 00c6 BB6A     	 ldr r3,[r7,#40]
 179 00c8 BA69     	 ldr r2,[r7,#24]
 180 00ca 02FB03F3 	 mul r3,r2,r3
 181 00ce 9B00     	 lsls r3,r3,#2
 182 00d0 7A6E     	 ldr r2,[r7,#100]
 183 00d2 1344     	 add r3,r3,r2
 184 00d4 3B66     	 str r3,[r7,#96]
 206:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 207:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points    
 208:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 209:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
 185              	 .loc 1 209 0
 186 00d6 BB6A     	 ldr r3,[r7,#40]
 187 00d8 BA69     	 ldr r2,[r7,#24]
 188 00da 02FB03F3 	 mul r3,r2,r3
 189 00de 9B00     	 lsls r3,r3,#2
 190 00e0 3A6A     	 ldr r2,[r7,#32]
 191 00e2 1344     	 add r3,r3,r2
 192 00e4 BB65     	 str r3,[r7,#88]
 210:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 211:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
 212:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
 193              	 .loc 1 212 0
 194 00e6 3B6E     	 ldr r3,[r7,#96]
 195 00e8 1B68     	 ldr r3,[r3]
 196 00ea 7B64     	 str r3,[r7,#68]
 213:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 214:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Grab the most significant value from column l */
 215:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       maxC = 0;
 197              	 .loc 1 215 0
 198 00ec 4FF00003 	 mov r3,#0
 199 00f0 BB64     	 str r3,[r7,#72]
 216:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = l; i < numRows; i++)
 200              	 .loc 1 216 0
 201 00f2 BB6A     	 ldr r3,[r7,#40]
 202 00f4 3B64     	 str r3,[r7,#64]
 203 00f6 31E0     	 b .L12
 204              	.L22:
 217:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 218:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
 205              	 .loc 1 218 0
 206 00f8 3B6E     	 ldr r3,[r7,#96]
 207 00fa 1B68     	 ldr r3,[r3]
 208 00fc 1846     	 mov r0,r3
 209 00fe 4FF00001 	 mov r1,#0
 210 0102 FFF7FEFF 	 bl __aeabi_fcmpgt
 211 0106 0346     	 mov r3,r0
 212 0108 002B     	 cmp r3,#0
 213 010a 0DD0     	 beq .L68
 214              	 .loc 1 218 0 is_stmt 0 discriminator 1
 215 010c 3B6E     	 ldr r3,[r7,#96]
 216 010e 1B68     	 ldr r3,[r3]
 217 0110 1846     	 mov r0,r3
 218 0112 B96C     	 ldr r1,[r7,#72]
 219 0114 FFF7FEFF 	 bl __aeabi_fcmpgt
 220 0118 0346     	 mov r3,r0
 221 011a 002B     	 cmp r3,#0
 222 011c 02D0     	 beq .L69
 223              	 .loc 1 218 0 discriminator 3
 224 011e 3B6E     	 ldr r3,[r7,#96]
 225 0120 1B68     	 ldr r3,[r3]
 226 0122 12E0     	 b .L18
 227              	.L69:
 228              	 .loc 1 218 0 discriminator 4
 229 0124 BB6C     	 ldr r3,[r7,#72]
 230 0126 10E0     	 b .L18
 231              	.L68:
 232              	 .loc 1 218 0 discriminator 2
 233 0128 3B6E     	 ldr r3,[r7,#96]
 234 012a 1B68     	 ldr r3,[r3]
 235 012c 83F00043 	 eor r3,r3,#-2147483648
 236 0130 1846     	 mov r0,r3
 237 0132 B96C     	 ldr r1,[r7,#72]
 238 0134 FFF7FEFF 	 bl __aeabi_fcmpgt
 239 0138 0346     	 mov r3,r0
 240 013a 002B     	 cmp r3,#0
 241 013c 04D0     	 beq .L70
 242              	 .loc 1 218 0 discriminator 8
 243 013e 3B6E     	 ldr r3,[r7,#96]
 244 0140 1B68     	 ldr r3,[r3]
 245 0142 83F00043 	 eor r3,r3,#-2147483648
 246 0146 00E0     	 b .L18
 247              	.L70:
 248              	 .loc 1 218 0 discriminator 9
 249 0148 BB6C     	 ldr r3,[r7,#72]
 250              	.L18:
 251              	 .loc 1 218 0 discriminator 12
 252 014a BB64     	 str r3,[r7,#72]
 219:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 += numCols;
 253              	 .loc 1 219 0 is_stmt 1 discriminator 12
 254 014c BB69     	 ldr r3,[r7,#24]
 255 014e 9B00     	 lsls r3,r3,#2
 256 0150 3A6E     	 ldr r2,[r7,#96]
 257 0152 1344     	 add r3,r3,r2
 258 0154 3B66     	 str r3,[r7,#96]
 216:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = l; i < numRows; i++)
 259              	 .loc 1 216 0 discriminator 12
 260 0156 3B6C     	 ldr r3,[r7,#64]
 261 0158 0133     	 adds r3,r3,#1
 262 015a 3B64     	 str r3,[r7,#64]
 263              	.L12:
 216:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = l; i < numRows; i++)
 264              	 .loc 1 216 0 is_stmt 0 discriminator 2
 265 015c 3A6C     	 ldr r2,[r7,#64]
 266 015e FB69     	 ldr r3,[r7,#28]
 267 0160 9A42     	 cmp r2,r3
 268 0162 C9D3     	 bcc .L22
 220:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 221:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 222:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 223:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if(maxC == 0.0f)
 269              	 .loc 1 223 0 is_stmt 1
 270 0164 B86C     	 ldr r0,[r7,#72]
 271 0166 4FF00001 	 mov r1,#0
 272 016a FFF7FEFF 	 bl __aeabi_fcmpeq
 273 016e 0346     	 mov r3,r0
 274 0170 002B     	 cmp r3,#0
 275 0172 01D0     	 beq .L71
 224:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 225:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 276              	 .loc 1 225 0
 277 0174 FB23     	 movs r3,#251
 278 0176 5EE1     	 b .L25
 279              	.L71:
 226:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 227:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 228:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Restore pInT1  */
 229:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 280              	 .loc 1 229 0
 281 0178 7B6E     	 ldr r3,[r7,#100]
 282 017a 3B66     	 str r3,[r7,#96]
 230:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 231:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
 232:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1u;
 283              	 .loc 1 232 0
 284 017c 0123     	 movs r3,#1
 285 017e FB62     	 str r3,[r7,#44]
 233:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       
 234:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is the most significant of the column */
 235:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if( (in > 0.0f ? in : -in) != maxC)
 286              	 .loc 1 235 0
 287 0180 786C     	 ldr r0,[r7,#68]
 288 0182 4FF00001 	 mov r1,#0
 289 0186 FFF7FEFF 	 bl __aeabi_fcmpgt
 290 018a 0346     	 mov r3,r0
 291 018c 002B     	 cmp r3,#0
 292 018e 01D0     	 beq .L72
 293              	 .loc 1 235 0 is_stmt 0 discriminator 1
 294 0190 7B6C     	 ldr r3,[r7,#68]
 295 0192 02E0     	 b .L28
 296              	.L72:
 297              	 .loc 1 235 0 discriminator 2
 298 0194 7B6C     	 ldr r3,[r7,#68]
 299 0196 83F00043 	 eor r3,r3,#-2147483648
 300              	.L28:
 301              	 .loc 1 235 0 discriminator 4
 302 019a 1846     	 mov r0,r3
 303 019c B96C     	 ldr r1,[r7,#72]
 304 019e FFF7FEFF 	 bl __aeabi_fcmpeq
 305 01a2 0346     	 mov r3,r0
 306 01a4 002B     	 cmp r3,#0
 307 01a6 69D1     	 bne .L29
 236:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 237:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
 238:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         i = numRows - (l + 1u);
 308              	 .loc 1 238 0 is_stmt 1
 309 01a8 FA69     	 ldr r2,[r7,#28]
 310 01aa BB6A     	 ldr r3,[r7,#40]
 311 01ac D31A     	 subs r3,r2,r3
 312 01ae 013B     	 subs r3,r3,#1
 313 01b0 3B64     	 str r3,[r7,#64]
 239:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 240:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         while(i > 0u)
 314              	 .loc 1 240 0
 315 01b2 60E0     	 b .L31
 316              	.L41:
 241:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 242:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
 243:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * l);
 317              	 .loc 1 243 0
 318 01b4 BB69     	 ldr r3,[r7,#24]
 319 01b6 BA6A     	 ldr r2,[r7,#40]
 320 01b8 02FB03F3 	 mul r3,r2,r3
 321 01bc 9B00     	 lsls r3,r3,#2
 322 01be 3A6E     	 ldr r2,[r7,#96]
 323 01c0 1344     	 add r3,r3,r2
 324 01c2 FB65     	 str r3,[r7,#92]
 244:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
 325              	 .loc 1 244 0
 326 01c4 BB69     	 ldr r3,[r7,#24]
 327 01c6 FA6A     	 ldr r2,[r7,#44]
 328 01c8 02FB03F3 	 mul r3,r2,r3
 329 01cc 9B00     	 lsls r3,r3,#2
 330 01ce BA6D     	 ldr r2,[r7,#88]
 331 01d0 1344     	 add r3,r3,r2
 332 01d2 7B65     	 str r3,[r7,#84]
 245:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 246:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Look for the most significant element to    
 247:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
 248:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           if((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
 333              	 .loc 1 248 0
 334 01d4 FB6D     	 ldr r3,[r7,#92]
 335 01d6 1B68     	 ldr r3,[r3]
 336 01d8 1846     	 mov r0,r3
 337 01da 4FF00001 	 mov r1,#0
 338 01de FFF7FEFF 	 bl __aeabi_fcmpgt
 339 01e2 0346     	 mov r3,r0
 340 01e4 002B     	 cmp r3,#0
 341 01e6 02D0     	 beq .L73
 342              	 .loc 1 248 0 is_stmt 0 discriminator 1
 343 01e8 FB6D     	 ldr r3,[r7,#92]
 344 01ea 1B68     	 ldr r3,[r3]
 345 01ec 03E0     	 b .L34
 346              	.L73:
 347              	 .loc 1 248 0 discriminator 2
 348 01ee FB6D     	 ldr r3,[r7,#92]
 349 01f0 1B68     	 ldr r3,[r3]
 350 01f2 83F00043 	 eor r3,r3,#-2147483648
 351              	.L34:
 352              	 .loc 1 248 0 discriminator 4
 353 01f6 1846     	 mov r0,r3
 354 01f8 B96C     	 ldr r1,[r7,#72]
 355 01fa FFF7FEFF 	 bl __aeabi_fcmpeq
 356 01fe 0346     	 mov r3,r0
 357 0200 002B     	 cmp r3,#0
 358 0202 32D0     	 beq .L74
 249:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 250:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns    
 251:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
 252:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols - l;
 359              	 .loc 1 252 0 is_stmt 1
 360 0204 BA69     	 ldr r2,[r7,#24]
 361 0206 BB6A     	 ldr r3,[r7,#40]
 362 0208 D31A     	 subs r3,r2,r3
 363 020a 7B63     	 str r3,[r7,#52]
 253:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 254:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             while(j > 0u)
 364              	 .loc 1 254 0
 365 020c 10E0     	 b .L37
 366              	.L38:
 255:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 256:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
 257:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
 367              	 .loc 1 257 0
 368 020e FB6D     	 ldr r3,[r7,#92]
 369 0210 1B68     	 ldr r3,[r3]
 370 0212 7B61     	 str r3,[r7,#20]
 258:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 371              	 .loc 1 258 0
 372 0214 FB6D     	 ldr r3,[r7,#92]
 373 0216 1A1D     	 adds r2,r3,#4
 374 0218 FA65     	 str r2,[r7,#92]
 375 021a 3A6E     	 ldr r2,[r7,#96]
 376 021c 1268     	 ldr r2,[r2]
 377 021e 1A60     	 str r2,[r3]
 259:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 378              	 .loc 1 259 0
 379 0220 3B6E     	 ldr r3,[r7,#96]
 380 0222 1A1D     	 adds r2,r3,#4
 381 0224 3A66     	 str r2,[r7,#96]
 382 0226 7A69     	 ldr r2,[r7,#20]
 383 0228 1A60     	 str r2,[r3]
 260:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 261:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
 262:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 384              	 .loc 1 262 0
 385 022a 7B6B     	 ldr r3,[r7,#52]
 386 022c 013B     	 subs r3,r3,#1
 387 022e 7B63     	 str r3,[r7,#52]
 388              	.L37:
 254:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 389              	 .loc 1 254 0
 390 0230 7B6B     	 ldr r3,[r7,#52]
 391 0232 002B     	 cmp r3,#0
 392 0234 EBD1     	 bne .L38
 263:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 264:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 265:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns of the destination matrix */
 266:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols;
 393              	 .loc 1 266 0
 394 0236 BB69     	 ldr r3,[r7,#24]
 395 0238 7B63     	 str r3,[r7,#52]
 267:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 268:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             while(j > 0u)
 396              	 .loc 1 268 0
 397 023a 10E0     	 b .L39
 398              	.L40:
 269:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 270:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the destination matrix */
 271:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
 399              	 .loc 1 271 0
 400 023c 7B6D     	 ldr r3,[r7,#84]
 401 023e 1B68     	 ldr r3,[r3]
 402 0240 7B61     	 str r3,[r7,#20]
 272:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 403              	 .loc 1 272 0
 404 0242 7B6D     	 ldr r3,[r7,#84]
 405 0244 1A1D     	 adds r2,r3,#4
 406 0246 7A65     	 str r2,[r7,#84]
 407 0248 BA6D     	 ldr r2,[r7,#88]
 408 024a 1268     	 ldr r2,[r2]
 409 024c 1A60     	 str r2,[r3]
 273:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 410              	 .loc 1 273 0
 411 024e BB6D     	 ldr r3,[r7,#88]
 412 0250 1A1D     	 adds r2,r3,#4
 413 0252 BA65     	 str r2,[r7,#88]
 414 0254 7A69     	 ldr r2,[r7,#20]
 415 0256 1A60     	 str r2,[r3]
 274:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 275:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
 276:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 416              	 .loc 1 276 0
 417 0258 7B6B     	 ldr r3,[r7,#52]
 418 025a 013B     	 subs r3,r3,#1
 419 025c 7B63     	 str r3,[r7,#52]
 420              	.L39:
 268:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 421              	 .loc 1 268 0
 422 025e 7B6B     	 ldr r3,[r7,#52]
 423 0260 002B     	 cmp r3,#0
 424 0262 EBD1     	 bne .L40
 277:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 278:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 279:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
 280:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1u;
 425              	 .loc 1 280 0
 426 0264 0123     	 movs r3,#1
 427 0266 BB63     	 str r3,[r7,#56]
 281:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 282:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
 283:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 428              	 .loc 1 283 0
 429 0268 08E0     	 b .L29
 430              	.L74:
 284:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 285:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 286:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
 287:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
 431              	 .loc 1 287 0
 432 026a FB6A     	 ldr r3,[r7,#44]
 433 026c 0133     	 adds r3,r3,#1
 434 026e FB62     	 str r3,[r7,#44]
 288:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 289:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Decrement the loop counter */
 290:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           i--;
 435              	 .loc 1 290 0
 436 0270 3B6C     	 ldr r3,[r7,#64]
 437 0272 013B     	 subs r3,r3,#1
 438 0274 3B64     	 str r3,[r7,#64]
 439              	.L31:
 240:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 440              	 .loc 1 240 0
 441 0276 3B6C     	 ldr r3,[r7,#64]
 442 0278 002B     	 cmp r3,#0
 443 027a 9BD1     	 bne .L41
 444              	.L29:
 291:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 292:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 293:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 294:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 295:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if((flag != 1u) && (in == 0.0f))
 445              	 .loc 1 295 0
 446 027c BB6B     	 ldr r3,[r7,#56]
 447 027e 012B     	 cmp r3,#1
 448 0280 09D0     	 beq .L42
 449              	 .loc 1 295 0 is_stmt 0 discriminator 1
 450 0282 786C     	 ldr r0,[r7,#68]
 451 0284 4FF00001 	 mov r1,#0
 452 0288 FFF7FEFF 	 bl __aeabi_fcmpeq
 453 028c 0346     	 mov r3,r0
 454 028e 002B     	 cmp r3,#0
 455 0290 01D0     	 beq .L42
 296:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 297:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 456              	 .loc 1 297 0 is_stmt 1
 457 0292 FB23     	 movs r3,#251
 458 0294 CFE0     	 b .L25
 459              	.L42:
 298:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 299:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 300:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
 301:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
 460              	 .loc 1 301 0
 461 0296 BB6A     	 ldr r3,[r7,#40]
 462 0298 BA69     	 ldr r2,[r7,#24]
 463 029a 02FB03F3 	 mul r3,r2,r3
 464 029e 9B00     	 lsls r3,r3,#2
 465 02a0 7A6E     	 ldr r2,[r7,#100]
 466 02a2 1344     	 add r3,r3,r2
 467 02a4 3B61     	 str r3,[r7,#16]
 302:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
 468              	 .loc 1 302 0
 469 02a6 BB6A     	 ldr r3,[r7,#40]
 470 02a8 BA69     	 ldr r2,[r7,#24]
 471 02aa 02FB03F3 	 mul r3,r2,r3
 472 02ae 9B00     	 lsls r3,r3,#2
 473 02b0 3A6A     	 ldr r2,[r7,#32]
 474 02b2 1344     	 add r3,r3,r2
 475 02b4 FB60     	 str r3,[r7,#12]
 303:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 304:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
 305:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
 476              	 .loc 1 305 0
 477 02b6 3B69     	 ldr r3,[r7,#16]
 478 02b8 3B66     	 str r3,[r7,#96]
 306:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pPivotRowDst;
 479              	 .loc 1 306 0
 480 02ba FB68     	 ldr r3,[r7,#12]
 481 02bc FB65     	 str r3,[r7,#92]
 307:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 308:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
 309:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pPivotRowIn;
 482              	 .loc 1 309 0
 483 02be 3B69     	 ldr r3,[r7,#16]
 484 02c0 1B68     	 ldr r3,[r3]
 485 02c2 7B64     	 str r3,[r7,#68]
 310:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 311:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns    
 312:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
 313:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = (numCols - l);
 486              	 .loc 1 313 0
 487 02c4 BA69     	 ldr r2,[r7,#24]
 488 02c6 BB6A     	 ldr r3,[r7,#40]
 489 02c8 D31A     	 subs r3,r2,r3
 490 02ca 7B63     	 str r3,[r7,#52]
 314:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 315:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(j > 0u)
 491              	 .loc 1 315 0
 492 02cc 0EE0     	 b .L44
 493              	.L45:
 316:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 317:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix    
 318:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 319:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT1;
 494              	 .loc 1 319 0
 495 02ce 3B6E     	 ldr r3,[r7,#96]
 496 02d0 1B68     	 ldr r3,[r3]
 497 02d2 BB60     	 str r3,[r7,#8]
 320:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1++ = in1 / in;
 498              	 .loc 1 320 0
 499 02d4 3C6E     	 ldr r4,[r7,#96]
 500 02d6 231D     	 adds r3,r4,#4
 501 02d8 3B66     	 str r3,[r7,#96]
 502 02da B868     	 ldr r0,[r7,#8]
 503 02dc 796C     	 ldr r1,[r7,#68]
 504 02de FFF7FEFF 	 bl __aeabi_fdiv
 505 02e2 0346     	 mov r3,r0
 506 02e4 2360     	 str r3,[r4]
 321:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 322:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 323:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 507              	 .loc 1 323 0
 508 02e6 7B6B     	 ldr r3,[r7,#52]
 509 02e8 013B     	 subs r3,r3,#1
 510 02ea 7B63     	 str r3,[r7,#52]
 511              	.L44:
 315:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 512              	 .loc 1 315 0
 513 02ec 7B6B     	 ldr r3,[r7,#52]
 514 02ee 002B     	 cmp r3,#0
 515 02f0 EDD1     	 bne .L45
 324:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 325:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 326:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns of the destination matrix */
 327:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numCols;
 516              	 .loc 1 327 0
 517 02f2 BB69     	 ldr r3,[r7,#24]
 518 02f4 7B63     	 str r3,[r7,#52]
 328:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 329:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(j > 0u)
 519              	 .loc 1 329 0
 520 02f6 0EE0     	 b .L46
 521              	.L47:
 330:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 331:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix    
 332:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 333:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT2;
 522              	 .loc 1 333 0
 523 02f8 FB6D     	 ldr r3,[r7,#92]
 524 02fa 1B68     	 ldr r3,[r3]
 525 02fc BB60     	 str r3,[r7,#8]
 334:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT2++ = in1 / in;
 526              	 .loc 1 334 0
 527 02fe FC6D     	 ldr r4,[r7,#92]
 528 0300 231D     	 adds r3,r4,#4
 529 0302 FB65     	 str r3,[r7,#92]
 530 0304 B868     	 ldr r0,[r7,#8]
 531 0306 796C     	 ldr r1,[r7,#68]
 532 0308 FFF7FEFF 	 bl __aeabi_fdiv
 533 030c 0346     	 mov r3,r0
 534 030e 2360     	 str r3,[r4]
 335:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 336:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 337:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 535              	 .loc 1 337 0
 536 0310 7B6B     	 ldr r3,[r7,#52]
 537 0312 013B     	 subs r3,r3,#1
 538 0314 7B63     	 str r3,[r7,#52]
 539              	.L46:
 329:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 540              	 .loc 1 329 0
 541 0316 7B6B     	 ldr r3,[r7,#52]
 542 0318 002B     	 cmp r3,#0
 543 031a EDD1     	 bne .L47
 338:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 339:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 340:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i    
 341:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
 342:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 343:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
 344:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 544              	 .loc 1 344 0
 545 031c 7B6E     	 ldr r3,[r7,#100]
 546 031e 3B66     	 str r3,[r7,#96]
 345:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pOut;
 547              	 .loc 1 345 0
 548 0320 3B6A     	 ldr r3,[r7,#32]
 549 0322 FB65     	 str r3,[r7,#92]
 346:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 347:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* index used to check for pivot element */
 348:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       i = 0u;
 550              	 .loc 1 348 0
 551 0324 0023     	 movs r3,#0
 552 0326 3B64     	 str r3,[r7,#64]
 349:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 350:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of rows */
 351:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /*  to be replaced by the sum of that row and a multiple of row i */
 352:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = numRows;
 553              	 .loc 1 352 0
 554 0328 FB69     	 ldr r3,[r7,#28]
 555 032a FB62     	 str r3,[r7,#44]
 353:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 354:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(k > 0u)
 556              	 .loc 1 354 0
 557 032c 60E0     	 b .L48
 558              	.L55:
 355:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 356:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
 357:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         if(i == l)
 559              	 .loc 1 357 0
 560 032e 3A6C     	 ldr r2,[r7,#64]
 561 0330 BB6A     	 ldr r3,[r7,#40]
 562 0332 9A42     	 cmp r2,r3
 563 0334 0CD1     	 bne .L49
 358:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 359:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,    
 360:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
 361:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
 564              	 .loc 1 361 0
 565 0336 BA69     	 ldr r2,[r7,#24]
 566 0338 BB6A     	 ldr r3,[r7,#40]
 567 033a D31A     	 subs r3,r2,r3
 568 033c 9B00     	 lsls r3,r3,#2
 569 033e 3A6E     	 ldr r2,[r7,#96]
 570 0340 1344     	 add r3,r3,r2
 571 0342 3B66     	 str r3,[r7,#96]
 362:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 363:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 += numCols;
 572              	 .loc 1 363 0
 573 0344 BB69     	 ldr r3,[r7,#24]
 574 0346 9B00     	 lsls r3,r3,#2
 575 0348 FA6D     	 ldr r2,[r7,#92]
 576 034a 1344     	 add r3,r3,r2
 577 034c FB65     	 str r3,[r7,#92]
 578 034e 44E0     	 b .L50
 579              	.L49:
 364:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 365:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         else
 366:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 367:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
 368:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
 580              	 .loc 1 368 0
 581 0350 3B6E     	 ldr r3,[r7,#96]
 582 0352 1B68     	 ldr r3,[r3]
 583 0354 7B64     	 str r3,[r7,#68]
 369:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 370:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
 371:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
 584              	 .loc 1 371 0
 585 0356 3B69     	 ldr r3,[r7,#16]
 586 0358 3B65     	 str r3,[r7,#80]
 372:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
 587              	 .loc 1 372 0
 588 035a FB68     	 ldr r3,[r7,#12]
 589 035c FB64     	 str r3,[r7,#76]
 373:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 374:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,    
 375:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
 376:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           j = (numCols - l);
 590              	 .loc 1 376 0
 591 035e BA69     	 ldr r2,[r7,#24]
 592 0360 BB6A     	 ldr r3,[r7,#40]
 593 0362 D31A     	 subs r3,r2,r3
 594 0364 7B63     	 str r3,[r7,#52]
 377:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 378:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           while(j > 0u)
 595              	 .loc 1 378 0
 596 0366 17E0     	 b .L51
 597              	.L52:
 379:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 380:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row    
 381:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 382:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT1;
 598              	 .loc 1 382 0
 599 0368 3B6E     	 ldr r3,[r7,#96]
 600 036a 1B68     	 ldr r3,[r3]
 601 036c BB60     	 str r3,[r7,#8]
 383:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1++ = in1 - (in * *pPRT_in++);
 602              	 .loc 1 383 0
 603 036e 3C6E     	 ldr r4,[r7,#96]
 604 0370 231D     	 adds r3,r4,#4
 605 0372 3B66     	 str r3,[r7,#96]
 606 0374 3B6D     	 ldr r3,[r7,#80]
 607 0376 1A1D     	 adds r2,r3,#4
 608 0378 3A65     	 str r2,[r7,#80]
 609 037a 1B68     	 ldr r3,[r3]
 610 037c 1846     	 mov r0,r3
 611 037e 796C     	 ldr r1,[r7,#68]
 612 0380 FFF7FEFF 	 bl __aeabi_fmul
 613 0384 0346     	 mov r3,r0
 614 0386 B868     	 ldr r0,[r7,#8]
 615 0388 1946     	 mov r1,r3
 616 038a FFF7FEFF 	 bl __aeabi_fsub
 617 038e 0346     	 mov r3,r0
 618 0390 2360     	 str r3,[r4]
 384:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 385:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 386:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 619              	 .loc 1 386 0
 620 0392 7B6B     	 ldr r3,[r7,#52]
 621 0394 013B     	 subs r3,r3,#1
 622 0396 7B63     	 str r3,[r7,#52]
 623              	.L51:
 378:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 624              	 .loc 1 378 0
 625 0398 7B6B     	 ldr r3,[r7,#52]
 626 039a 002B     	 cmp r3,#0
 627 039c E4D1     	 bne .L52
 387:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 388:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 389:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to    
 390:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
 391:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           j = numCols;
 628              	 .loc 1 391 0
 629 039e BB69     	 ldr r3,[r7,#24]
 630 03a0 7B63     	 str r3,[r7,#52]
 392:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 393:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           while(j > 0u)
 631              	 .loc 1 393 0
 632 03a2 17E0     	 b .L53
 633              	.L54:
 394:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 395:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row    
 396:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 397:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT2;
 634              	 .loc 1 397 0
 635 03a4 FB6D     	 ldr r3,[r7,#92]
 636 03a6 1B68     	 ldr r3,[r3]
 637 03a8 BB60     	 str r3,[r7,#8]
 398:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT2++ = in1 - (in * *pPRT_pDst++);
 638              	 .loc 1 398 0
 639 03aa FC6D     	 ldr r4,[r7,#92]
 640 03ac 231D     	 adds r3,r4,#4
 641 03ae FB65     	 str r3,[r7,#92]
 642 03b0 FB6C     	 ldr r3,[r7,#76]
 643 03b2 1A1D     	 adds r2,r3,#4
 644 03b4 FA64     	 str r2,[r7,#76]
 645 03b6 1B68     	 ldr r3,[r3]
 646 03b8 1846     	 mov r0,r3
 647 03ba 796C     	 ldr r1,[r7,#68]
 648 03bc FFF7FEFF 	 bl __aeabi_fmul
 649 03c0 0346     	 mov r3,r0
 650 03c2 B868     	 ldr r0,[r7,#8]
 651 03c4 1946     	 mov r1,r3
 652 03c6 FFF7FEFF 	 bl __aeabi_fsub
 653 03ca 0346     	 mov r3,r0
 654 03cc 2360     	 str r3,[r4]
 399:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 400:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 401:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 655              	 .loc 1 401 0
 656 03ce 7B6B     	 ldr r3,[r7,#52]
 657 03d0 013B     	 subs r3,r3,#1
 658 03d2 7B63     	 str r3,[r7,#52]
 659              	.L53:
 393:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 660              	 .loc 1 393 0
 661 03d4 7B6B     	 ldr r3,[r7,#52]
 662 03d6 002B     	 cmp r3,#0
 663 03d8 E4D1     	 bne .L54
 664              	.L50:
 402:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 403:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 404:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 405:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 406:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the temporary input pointer */
 407:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
 665              	 .loc 1 407 0
 666 03da BB6A     	 ldr r3,[r7,#40]
 667 03dc 9B00     	 lsls r3,r3,#2
 668 03de 3A6E     	 ldr r2,[r7,#96]
 669 03e0 1344     	 add r3,r3,r2
 670 03e2 3B66     	 str r3,[r7,#96]
 408:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 409:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 410:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         k--;
 671              	 .loc 1 410 0
 672 03e4 FB6A     	 ldr r3,[r7,#44]
 673 03e6 013B     	 subs r3,r3,#1
 674 03e8 FB62     	 str r3,[r7,#44]
 411:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 412:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the pivot index */
 413:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         i++;
 675              	 .loc 1 413 0
 676 03ea 3B6C     	 ldr r3,[r7,#64]
 677 03ec 0133     	 adds r3,r3,#1
 678 03ee 3B64     	 str r3,[r7,#64]
 679              	.L48:
 354:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 680              	 .loc 1 354 0
 681 03f0 FB6A     	 ldr r3,[r7,#44]
 682 03f2 002B     	 cmp r3,#0
 683 03f4 9BD1     	 bne .L55
 414:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 415:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 416:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
 417:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
 684              	 .loc 1 417 0
 685 03f6 7B6E     	 ldr r3,[r7,#100]
 686 03f8 0433     	 adds r3,r3,#4
 687 03fa 7B66     	 str r3,[r7,#100]
 418:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 419:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 420:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
 688              	 .loc 1 420 0
 689 03fc 3B6B     	 ldr r3,[r7,#48]
 690 03fe 013B     	 subs r3,r3,#1
 691 0400 3B63     	 str r3,[r7,#48]
 421:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 422:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
 423:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
 692              	 .loc 1 423 0
 693 0402 BB6A     	 ldr r3,[r7,#40]
 694 0404 0133     	 adds r3,r3,#1
 695 0406 BB62     	 str r3,[r7,#40]
 696              	.L11:
 196:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 697              	 .loc 1 196 0
 698 0408 3B6B     	 ldr r3,[r7,#48]
 699 040a 002B     	 cmp r3,#0
 700 040c 7FF45BAE 	 bne .L56
 424:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 425:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 426:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 427:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #else
 428:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 429:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Run the below code for Cortex-M0 */
 430:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 431:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f;                     /* Temporary input values  */
 432:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
 433:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
 434:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 435:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
 436:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 437:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
 438:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
 439:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
 440:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 441:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
 442:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
 443:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 444:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   else
 445:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
 446:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 447:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 448:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
 449:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 * Matrix Inverse can be solved using elementary row operations.        
 450:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *        
 451:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	Gauss-Jordan Method:       
 452:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	 	       
 453:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an     
 454:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *        augmented matrix as follows:        
 455:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *				        _  _	      _	    _	   _   _         _	       _       
 456:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |         
 457:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  |            | | |        |   |   =   |           |        
 458:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|       
 459:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					          
 460:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
 461:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *       
 462:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		3. Begin with the first row. Let i = 1.       
 463:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *       
 464:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    4. Check to see if the pivot for row i is zero.       
 465:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The pivot is the element of the main diagonal that is on the current row.       
 466:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   For instance, if working with row i, then the pivot element is aii.       
 467:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   If the pivot is zero, exchange that row with a row below it that does not        
 468:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   contain a zero in column i. If this is not possible, then an inverse        
 469:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   to that matrix does not exist.       
 470:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	       
 471:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    5. Divide every element of row i by the pivot.       
 472:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	       
 473:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    6. For every row below and  row i, replace that row with the sum of that row and        
 474:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   a multiple of row i so that each new element in column i below row i is zero.       
 475:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	       
 476:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros       
 477:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   for every element below and above the main diagonal.        
 478:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   		          
 479:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).       
 480:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).         
 481:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *------------------------------------------------------------------------------------------------
 482:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 483:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
 484:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
 485:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 486:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
 487:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
 488:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 489:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
 490:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while(rowCnt > 0u)
 491:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 492:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 493:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
 494:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(j > 0u)
 495:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 496:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 497:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 498:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 499:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 500:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
 501:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
 502:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 503:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 504:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1u;
 505:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while(j > 0u)
 506:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 507:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 508:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 509:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 510:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 511:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 512:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
 513:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 514:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 515:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.     
 516:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
 517:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
 518:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 519:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
 520:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0u;
 521:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     //for(loopCnt = 0u; loopCnt < numCols; loopCnt++)   
 522:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while(loopCnt > 0u)
 523:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 524:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..    
 525:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.   
 526:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,   
 527:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
 528:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 529:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points     
 530:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 531:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
 532:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 533:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points     
 534:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 535:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
 536:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 537:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
 538:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
 539:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 540:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
 541:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1u;
 542:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 543:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero */
 544:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if(*pInT1 == 0.0f)
 545:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 546:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
 547:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         for (i = (l + 1u); i < numRows; i++)
 548:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 549:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
 550:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * l);
 551:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
 552:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 553:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Check if there is a non zero pivot element to     
 554:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
 555:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           if(*pInT2 != 0.0f)
 556:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 557:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns     
 558:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
 559:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             for (j = 0u; j < (numCols - l); j++)
 560:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 561:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
 562:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
 563:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 564:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 565:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 566:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 567:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             for (j = 0u; j < numCols; j++)
 568:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 569:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
 570:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 571:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 572:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 573:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 574:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
 575:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1u;
 576:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 577:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
 578:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 579:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 580:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 581:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
 582:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
 583:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 584:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 585:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 586:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 587:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if((flag != 1u) && (in == 0.0f))
 588:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 589:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 590:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 591:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 592:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
 593:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
 594:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
 595:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 596:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
 597:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
 598:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pPivotRowDst;
 599:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 600:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
 601:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *(pIn + (l * numCols));
 602:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 603:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns     
 604:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
 605:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (j = 0u; j < (numCols - l); j++)
 606:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 607:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix     
 608:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 609:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1 = *pInT1 / in;
 610:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1++;
 611:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 612:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (j = 0u; j < numCols; j++)
 613:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 614:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix     
 615:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 616:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1 = *pOutT1 / in;
 617:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pOutT1++;
 618:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 619:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 620:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i     
 621:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
 622:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 623:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
 624:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 625:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut;
 626:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 627:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0u; i < numRows; i++)
 628:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 629:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
 630:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         if(i == l)
 631:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 632:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,     
 633:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
 634:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
 635:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT1 += numCols;
 636:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 637:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         else
 638:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 639:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
 640:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
 641:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 642:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
 643:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
 644:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
 645:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 646:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,     
 647:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
 648:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           for (j = 0u; j < (numCols - l); j++)
 649:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 650:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row     
 651:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 652:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1 = *pInT1 - (in * *pPRT_in++);
 653:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1++;
 654:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 655:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to     
 656:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
 657:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           for (j = 0u; j < numCols; j++)
 658:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 659:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row     
 660:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 661:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
 662:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             pOutT1++;
 663:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 664:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 665:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 666:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the temporary input pointer */
 667:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
 668:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 669:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
 670:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
 671:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 672:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 673:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
 674:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
 675:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
 676:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 677:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 678:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 679:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /* #ifndef ARM_MATH_CM0_FAMILY */
 680:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 681:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SUCCESS */
 682:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SUCCESS;
 701              	 .loc 1 682 0
 702 0410 0023     	 movs r3,#0
 703 0412 87F82730 	 strb r3,[r7,#39]
 683:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 684:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     if((flag != 1u) && (in == 0.0f))
 704              	 .loc 1 684 0
 705 0416 BB6B     	 ldr r3,[r7,#56]
 706 0418 012B     	 cmp r3,#1
 707 041a 0AD0     	 beq .L4
 708              	 .loc 1 684 0 is_stmt 0 discriminator 1
 709 041c 786C     	 ldr r0,[r7,#68]
 710 041e 4FF00001 	 mov r1,#0
 711 0422 FFF7FEFF 	 bl __aeabi_fcmpeq
 712 0426 0346     	 mov r3,r0
 713 0428 002B     	 cmp r3,#0
 714 042a 02D0     	 beq .L4
 685:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 686:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       status = ARM_MATH_SINGULAR;
 715              	 .loc 1 686 0 is_stmt 1
 716 042c FB23     	 movs r3,#251
 717 042e 87F82730 	 strb r3,[r7,#39]
 718              	.L4:
 687:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 688:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 689:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Return to application */
 690:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   return (status);
 719              	 .loc 1 690 0
 720 0432 97F82730 	 ldrb r3,[r7,#39]
 721              	.L25:
 722 0436 5BB2     	 sxtb r3,r3
 691:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** }
 723              	 .loc 1 691 0
 724 0438 1846     	 mov r0,r3
 725 043a 6C37     	 adds r7,r7,#108
 726              	.LCFI3:
 727              	 .cfi_def_cfa_offset 12
 728 043c BD46     	 mov sp,r7
 729              	.LCFI4:
 730              	 .cfi_def_cfa_register 13
 731              	 
 732 043e 90BD     	 pop {r4,r7,pc}
 733              	 .cfi_endproc
 734              	.LFE139:
 736              	 .text
 737              	.Letext0:
 738              	 .file 2 "c:\\davev4-64bit\\dave-4.2.6\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 739              	 .file 3 "c:\\davev4-64bit\\dave-4.2.6\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 740              	 .file 4 "C:\\Users\\Depes Crystalline\\Desktop\\school\\Active_Bike_Lighting_System\\Radar_Core\\Dave\\Generated/CMSIS_DSP/arm_math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 arm_mat_inverse_f32.c
    {standard input}:24     .text.arm_mat_inverse_f32:00000000 $t
    {standard input}:29     .text.arm_mat_inverse_f32:00000000 arm_mat_inverse_f32
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_fcmpgt
__aeabi_fcmpeq
__aeabi_fdiv
__aeabi_fmul
__aeabi_fsub
