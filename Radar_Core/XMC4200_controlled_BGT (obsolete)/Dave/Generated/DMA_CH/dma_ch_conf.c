/*********************************************************************************************************************
* DAVE APP Name : DMA_CH       APP Version: 4.1.4
*
* NOTE:
* This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
*********************************************************************************************************************/

/**
 * @cond
 ***********************************************************************************************************************
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version <br>
 *
 * 2015-04-15:
 *     - Handle src/dst address updates with new APIs in DMA LLD <br>
 *     - Documentation updates <br>
 *     - The major, minor and patch numbers are now auto-magically updated using Groovy <br>
 *
 * 2015-06-20:
 *     - Changes in the way src and dst addresses are handled <br>
 *     - APP_INSTANCE_reload() API updated to add XMC_DMA_CH_SetBlockSize() call <br>
 *
 * 2015-07-15:
 *     - DMA_CH (Request #70158): Fix source and destination address handling <br>
 *
 * @endcond
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include "dma_ch.h"

/**********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/

extern uint32_t* pDMA_src_IFQ; /* Source address symbol */

extern uint32_t* pDMA_dst_IFQ; /* Destination address symbol */

void DMA_CH_IFQ_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
  XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);

  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 1024);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_IFQ);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_IFQ);
}

DMA_CH_CONFIG_t DMA_CH_IFQ_CONFIG =
{
  {
	{
      .enable_interrupt = true, /* Interrupts enabled */
      .dst_transfer_width = XMC_DMA_CH_TRANSFER_WIDTH_16, /* Destination transfer width */
      .src_transfer_width = XMC_DMA_CH_TRANSFER_WIDTH_16, /* Source transfer width */
      .dst_address_count_mode = XMC_DMA_CH_ADDRESS_COUNT_MODE_INCREMENT, /* Destination address count mode */
      .src_address_count_mode = XMC_DMA_CH_ADDRESS_COUNT_MODE_NO_CHANGE, /* Source address count mode */
      .dst_burst_length = XMC_DMA_CH_BURST_LENGTH_1, /* Destination burst length */
      .src_burst_length = XMC_DMA_CH_BURST_LENGTH_1, /* Source burst length */
      .enable_src_gather = false, /* Source gather enabled? */
      .enable_dst_scatter = false, /* Destination scatter enabled? */
      .transfer_flow = XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA, /* Transfer flow */
    },
    .block_size = 1024U, /* Block size */
    .transfer_type = XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS, /* Transfer type */
    .priority = XMC_DMA_CH_PRIORITY_0, /* Priority level */
    .src_handshaking = XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE, /* Source handshaking */
    .src_peripheral_request = DMA_PERIPHERAL_REQUEST(7, 2), /* Source peripheral trigger */
    .dst_handshaking = XMC_DMA_CH_DST_HANDSHAKING_SOFTWARE  /* Destination handshaking */
  },
  DMA_IFQ_event_handler,
  XMC_DMA_CH_EVENT_ERROR | XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE
};

DMA_CH_t DMA_CH_IFQ =
{
  .dma_global = &GLOBAL_DMA_0, /* Which DMA_GLOBAL instance? */
  .config = &DMA_CH_IFQ_CONFIG, /* Channel configuration */
  .ch_num = 0U, /* Channel number */
  .reload = DMA_CH_IFQ_reload
};

extern uint32_t* pDMA_src_IFI; /* Source address symbol */

extern uint32_t* pDMA_dst_IFI; /* Destination address symbol */

void DMA_CH_IFI_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 1024);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_IFI);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_IFI);
}

DMA_CH_CONFIG_t DMA_CH_IFI_CONFIG =
{
  {
	{
      .enable_interrupt = false, /* Interrupts disabled */
      .dst_transfer_width = XMC_DMA_CH_TRANSFER_WIDTH_16, /* Destination transfer width */
      .src_transfer_width = XMC_DMA_CH_TRANSFER_WIDTH_16, /* Source transfer width */
      .dst_address_count_mode = XMC_DMA_CH_ADDRESS_COUNT_MODE_INCREMENT, /* Destination address count mode */
      .src_address_count_mode = XMC_DMA_CH_ADDRESS_COUNT_MODE_NO_CHANGE, /* Source address count mode */
      .dst_burst_length = XMC_DMA_CH_BURST_LENGTH_1, /* Destination burst length */
      .src_burst_length = XMC_DMA_CH_BURST_LENGTH_1, /* Source burst length */
      .enable_src_gather = false, /* Source gather enabled? */
      .enable_dst_scatter = false, /* Destination scatter enabled? */
      .transfer_flow = XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA, /* Transfer flow */
    },
    .block_size = 1024U, /* Block size */
    .transfer_type = XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS, /* Transfer type */
    .priority = XMC_DMA_CH_PRIORITY_1, /* Priority level */
    .src_handshaking = XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE, /* Source handshaking */
    .src_peripheral_request = DMA_PERIPHERAL_REQUEST(3, 1), /* Source peripheral trigger */
    .dst_handshaking = XMC_DMA_CH_DST_HANDSHAKING_SOFTWARE  /* Destination handshaking */
  },
  NULL,
  0U
};

DMA_CH_t DMA_CH_IFI =
{
  .dma_global = &GLOBAL_DMA_0, /* Which DMA_GLOBAL instance? */
  .config = &DMA_CH_IFI_CONFIG, /* Channel configuration */
  .ch_num = 1U, /* Channel number */
  .reload = DMA_CH_IFI_reload
};

