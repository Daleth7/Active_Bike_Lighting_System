/**
 * @file spi_master.h
 * @date 2015-07-07
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * SPI_MASTER v4.2.6 - Configures the properties of USIC channel to support SPI mode of communication.
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version<br>
 *
 * 2015-02-20:
 *     - Added 'SPI_MASTER_INPUT_INVALID' in SPI_MASTER_INPUT_t to support dynamic mode change from Dual mode
 *       as well<br>
 *
 * 2015-05-08:
 *     - SPI_MASTER_SetBaudRate() and SPI_MASTER_Transfer() are added<br>
 *     - C++ guard applied to API section only<br>
 *     - File guard updated according to the guidelines<br>
 *     - "SPI_MASTER_STATUS_BUFFER_INVALID" is added in SPI_MASTER_STATUS_t enum<br>
 *     - "leading_trailing_delay" is added in APP config structure<br>
 *     - "tx_data_dummy" is added in Dynamic config structure to support SPI_MASTER_Transfer() API<br>
 *     - XMC_ASSERT() are for NULL handle check in inline APIs<br>
 *     - SPI_MASTER_lTransmitHandler(), SPI_MASTER_lReceiveHandler(), SPI_MASTER_lProtocolHandler() are moved to
 *       spi_master_conf.c file<br>
 *
 * 2015-06-20:
 *     - For SPI_MASTER_Transfer(), SPI_MASTER_Receive(), SPI_MASTER_Transmit() APIs, the input data pointer is changed
 *       from 16-bit to 8-bit.
 *     - word_length fields is added in SPI_MASTER_DYNAMIC_CONFIG_t, to support runtime change.
 *     - Abort API are updated to return the status.
 *
 * 2015-07-07:
 *     - DYNAMIC_CONFIG_t is renamed as RUNTIME_t
 *
 * @endcond
 *
 */

#ifndef SPI_MASTER_H
#define SPI_MASTER_H
/***********************************************************************************************************************
**                                     System Header file inclusion                                                   **
***********************************************************************************************************************/
#include <xmc_gpio.h>
#include <xmc_spi.h>
#include <DAVE_Common.h>
#include "spi_master_conf.h"

/**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "SPI_MASTER requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
typedef void (*SPI_MASTER_functionhandler)(void);

/**
 * @ingroup SPI_MASTER_enumerations
 * @{
 */
/**
 * @brief Return status of the SPI_MASTER APP
 */
typedef enum SPI_MASTER_STATUS
{
  SPI_MASTER_STATUS_SUCCESS = 0U,   /**< Status success */
  SPI_MASTER_STATUS_FAILURE,        /**< Status failure */
  SPI_MASTER_STATUS_BUSY,           /**< Busy state */
  SPI_MASTER_STATUS_BUFFER_INVALID  /**< If input buffer and length is invalid */
} SPI_MASTER_STATUS_t;

/**
 * @brief Service ID for Transmit, Receive and Parity events
 */
typedef enum SPI_MASTER_SR_ID
{
  SPI_MASTER_SR_ID_0 = 0U, /**< SR-0 */
  SPI_MASTER_SR_ID_1,      /**< SR-1 */
  SPI_MASTER_SR_ID_2,      /**< SR-2 */
  SPI_MASTER_SR_ID_3,      /**< SR-3 */
  SPI_MASTER_SR_ID_4,      /**< SR-4 */
  SPI_MASTER_SR_ID_5       /**< SR-5 */
} SPI_MASTER_SR_ID_t;

/**
 * @brief Slave select signals
 */
typedef enum SPI_MASTER_SS_SIGNAL
{
  SPI_MASTER_SS_SIGNAL_0 = 0U, /**< Slave select 0 */
  SPI_MASTER_SS_SIGNAL_1,      /**< Slave select 1 */
  SPI_MASTER_SS_SIGNAL_2,      /**< Slave select 2 */
  SPI_MASTER_SS_SIGNAL_3,      /**< Slave select 3 */
  SPI_MASTER_SS_SIGNAL_4,      /**< Slave select 4 */
  SPI_MASTER_SS_SIGNAL_5,      /**< Slave select 5 */
  SPI_MASTER_SS_SIGNAL_6,      /**< Slave select 6 */
  SPI_MASTER_SS_SIGNAL_7       /**< Slave select 7 */
} SPI_MASTER_SS_SIGNAL_t;

/**
 * @brief Enum type which defines Receive input list
 */
typedef enum SPI_MASTER_INPUT
{
  SPI_MASTER_INPUT_A = 0U, /**< Input-A */
  SPI_MASTER_INPUT_B,      /**< Input-B */
  SPI_MASTER_INPUT_C,      /**< Input-C */
  SPI_MASTER_INPUT_D,      /**< Input-D */
  SPI_MASTER_INPUT_E,      /**< Input-E */
  SPI_MASTER_INPUT_F,      /**< Input-F */
  SPI_MASTER_INPUT_G,      /**< Input-G */
  SPI_MASTER_INPUT_INVALID /**< This is to check during mode switch */
} SPI_MASTER_INPUT_t;
/**
 * @}
 */

/***********************************************************************************************************************
* DATA STRUCTURES
***********************************************************************************************************************/
/**
* @ingroup SPI_MASTER_datastructures
* @{
*/

/**
 * @brief Port pin selection for communication
 */
typedef struct SPI_MASTER_GPIO
{
  XMC_GPIO_PORT_t* port;  /**< Reference to the port configuration */
  uint8_t pin;  /**< Selected pin */
} SPI_MASTER_GPIO_t;

/**
 * @brief Pin configuration for the selected pins
 */
typedef struct SPI_MASTER_GPIO_CONFIG
{
  XMC_GPIO_CONFIG_t port_config;  /**< Properties of the port pin */
  XMC_GPIO_HWCTRL_t hw_control;  /**<  hardware control characteristics of the pin */
  XMC_SPI_CH_SLAVE_SELECT_t slave_select_ch;  /**<  Indicates the mapped slave select line  */
} SPI_MASTER_GPIO_CONFIG_t;

/**
 * @brief Configuration parameters of SPI_MASTER APP
 */
 typedef struct SPI_MASTER_CONFIG
{
  XMC_SPI_CH_CONFIG_t * const channel_config;         /**< Reference to SPI configuration structure */
  SPI_MASTER_functionhandler fptr_spi_master_config;  /**< Function pointer to configure the MUX values*/

  /* Port configuration */
  const SPI_MASTER_GPIO_t* const mosi_0_pin;               /**< Reference to mosi 0 pin */
  const SPI_MASTER_GPIO_CONFIG_t* const mosi_0_pin_config; /**< Reference to mosi 0 pin configuration */
  const SPI_MASTER_GPIO_t* const mosi_1_pin;               /**< Reference to mosi 1 pin */
  const SPI_MASTER_GPIO_CONFIG_t* const mosi_1_pin_config; /**< Reference to mosi 1 pin configuration */
  const SPI_MASTER_GPIO_t* const mosi_2_pin;               /**< Reference to mosi 2 pin */
  const SPI_MASTER_GPIO_CONFIG_t* const mosi_2_pin_config; /**< Reference to mosi 2 pin configuration */
  const SPI_MASTER_GPIO_t* const mosi_3_pin;               /**< Reference to mosi 3 pin */
  const SPI_MASTER_GPIO_CONFIG_t* const mosi_3_pin_config; /**< Reference to mosi 3 pin configuration */
  const SPI_MASTER_GPIO_t* const sclk_out_pin;             /**< Reference to sclk out pin */
  const SPI_MASTER_GPIO_CONFIG_t* const sclk_out_pin_config;/**< Reference to shift clock pin configuration */
  const SPI_MASTER_GPIO_t* const slave_select_pin[8];      /**< Reference to slave select pin */
  const SPI_MASTER_GPIO_CONFIG_t* const slave_select_pin_config[8]; /**< Reference to slave select pin configuration */
  SPI_MASTER_functionhandler tx_cbhandler;            /**< callback handler for end of transmission */
  SPI_MASTER_functionhandler rx_cbhandler;            /**< callback handler for end of reception */
  SPI_MASTER_functionhandler parity_cbhandler;        /**< callback handler for end of parity error */
  /* FIFO configuration */
  XMC_USIC_CH_FIFO_SIZE_t tx_fifo_size;               /**< Number of FIFO entries assigned to the transmit FIFO buffer*/
  XMC_USIC_CH_FIFO_SIZE_t rx_fifo_size;               /**< Number of FIFO entries assigned to the receive FIFO buffer */
  /* Clock Settings */
  XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t shift_clk_passive_level; /**< Baudrate Generator shift clock passive level*/
  uint8_t slave_select_lines;                         /**< Number of slave select lines being used */
  uint8_t leading_trailing_delay;                     /**< Delay before and after each frame in terms of SCLK cycles  */
  SPI_MASTER_SR_ID_t tx_sr;                           /**< Service request number assigned to transmit interrupt */
  SPI_MASTER_SR_ID_t rx_sr;                           /**< Service request number assigned to receive interrupts */
  SPI_MASTER_SR_ID_t parity_sr;                       /**< Service request number assigned to receive interrupts */
} SPI_MASTER_CONFIG_t;

/**
 * @brief Structure to hold the dynamic variables for the SPI_MASTER communication.
 */
typedef struct SPI_MASTER_RUNTIME
{
  uint32_t tx_data_count;                            /**< Number of bytes of data to be transmitted*/
  uint32_t tx_data_index;                            /**< Index to the byte to be transmitted next in the tx_data
                                                          buffer */
  uint32_t word_length;                              /**< Indicates the length of the data word */
  uint32_t rx_data_count;                            /**< Number of bytes of data to be received*/
  uint32_t rx_data_index;                            /**< Indicates the number of bytes currently available in the
                                                          rx_data buffer */
  uint8_t * tx_data;                                /**< Pointer to the transmit data buffer*/
  uint8_t * rx_data;                                /**< Pointer to the receive data buffer*/
  XMC_SPI_CH_MODE_t spi_master_mode;                 /**< Defines the SPI transmit mode being used */
  SPI_MASTER_INPUT_t dx0_input;                      /**< DX0 input channel used for Rx input */
  bool tx_busy;                                      /**< Status flag to indicate busy when a transmission is assigned*/
  bool rx_busy;                                      /**< Status flag to indicate busy when a reception is assigned */
  bool tx_data_dummy;                                /**< Status flag to indicate busy when a reception is assigned */
} SPI_MASTER_RUNTIME_t;


/**
 * @brief Initialization parameters of SPI_MASTER APP
 */
typedef struct SPI_MASTER
{
  XMC_USIC_CH_t* const channel;                /**< Reference to SPI channel */
  const SPI_MASTER_CONFIG_t * const config;    /**< Reference to the SPI_MASTER configuration structure */
  SPI_MASTER_RUNTIME_t * const runtime;  /**< Reference to SPI_MASTER dynamic configuration structure */
} SPI_MASTER_t;

/**
 * @}
 */
/***********************************************************************************************************************
* API Prototypes
***********************************************************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif
/**
 * @ingroup SPI_MASTER_apidoc
 * @{
 */
/**
 * @brief Get SPI_MASTER APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 * <BR>
 * \par<b>Description:</b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t app_version;
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *
 *   app_version = SPI_MASTER_GetAppVersion();
 *
 *   if (app_version.major != 4U)
 *   {
 *     // Probably, not the right version.
 *   }
 *
 *   while(1U)
 *   {
 *   }
 *   return 1;
 * }
 * @endcode<BR>
 */
DAVE_APP_VERSION_t SPI_MASTER_GetAppVersion(void);

/**
 * @brief Initialize the SPI channel as per the configuration made in GUI.
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return SPI_MASTER_STATUS_t: Status of UART driver initialization.\n
 *                    SPI_MASTER_STATUS_SUCCESS - on successful initialization.\n
 *                    SPI_MASTER_STATUS_FAILURE - if initialization fails.\n
 *
 * \par<b>Description:</b><br>
 * Initializes IO pins used for the UART communication and configures USIC registers based on the settings provided
 * in the GUI. Calculates divider values PDIV and STEP for a precise baudrate. It also enables configured interrupt
 * flags and service request values.
 * <BR>
 *
 * Example Usage:
 * @code
 *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  int main(void)
 *  {
 *    DAVE_STATUS_t status;
 *
 *    status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *
 *    if(status == DAVE_STATUS_SUCCESS)
 *    {
 *        while(1U)
 *        {
 *        }
 *    }
 *    else
 *    {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *    }
 *     return 1U;
 * }
 *  @endcode
 */
SPI_MASTER_STATUS_t SPI_MASTER_Init(SPI_MASTER_t* const handle);

/**
 * @brief Set the communication mode along with required port configuration.
 *
 * @param handle handle Pointer to static and dynamic content of APP configuration.
 * @param mode SPI working mode
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS  : if updation of settings are successful\n
 *          SPI_MASTER_STATUS_FAILURE  : if mode is not supported by the selected pins\n
 *          SPI_MASTER_STATUS_BUSY     : if SPI channel is busy with transmit or receive operation\n
 * <BR>
 *
 * \par<b>Description:</b><br>
 * To change the mode of communication, it is advised to generate the code in Quad/Dual mode initially. Then changing
 * the mode will be taken care by the APP.
 * <ul>
 * <li>If code is generated for Quad mode, it is possible to change to other modes like Dual, Half Duplex and Full Duplex </li>
 * <li>If code is generated for Dual mode, it is possible to change to other modes like Half Duplex and Full Duplex only </li>
 * </ul>
 * 
 * <BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   SPI_MASTER_STATUS_t spi_status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *    spi_status = SPI_MASTER_SetMode(&SPI_MASTER_0, XMC_SPI_CH_MODE_STANDARD);
 *    if(spi_status == SPI_MASTER_STATUS_SUCCESS)
 *    {
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *    }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */

SPI_MASTER_STATUS_t SPI_MASTER_SetMode(SPI_MASTER_t* const handle, const XMC_SPI_CH_MODE_t mode);

/**
 * @brief Set the required baud rate during runtime.
 *
 * @param handle handle Pointer to static and dynamic content of APP configuration.
 * @param baud_rate required baud rate
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS  : if updation of baud rate is successful\n
 *          SPI_MASTER_STATUS_FAILURE  : if updation is failed\n
 *          SPI_MASTER_STATUS_BUSY     : if SPI channel is busy with other operation\n
 * <BR>
 *
 * \par<b>Description:</b><br>
 * While setting the baud rate to avoid noise of the port pins, all the pins are changed to input. After setting the
 * required baud again ports are initialised with the configured settings.
 * <BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   SPI_MASTER_STATUS_t spi_status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     spi_status = SPI_MASTER_SetMode(&SPI_MASTER_0, XMC_SPI_CH_MODE_STANDARD);
 *     if(spi_status == SPI_MASTER_STATUS_SUCCESS)
 *     {
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
SPI_MASTER_STATUS_t SPI_MASTER_SetBaudRate(SPI_MASTER_t* const handle, const uint32_t baud_rate);

/**
 * @brief Transmits and Receives the specified number of data words and execute the receive callback if it is enabled
 *        in GUI.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param tx_dataptr Pointer to data buffer which has to be send
 * @param rx_dataptr Pointer to data buffer where the received data has to be stored.
 * @param count number of data words (word length configured) to be read and write
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS   : if transfer of data is successful\n
 *          SPI_MASTER_STATUS_FAILURE   : if transfer of data is failed (or) in other than standard full duplex mode
 *          SPI_MASTER_STATUS_BUFFER_INVALID : if passed buffers are NULL pointers (or) length of data transfer is zero.
 * <BR>
 * \par<b>Description:</b><br>
 * After sending and receiving the specified number of words (word length configured), the user configured callback
 * function is executed, if it is enabled. If a callback function is not configured on the APP UI, the user has to poll
 * for the status of rx_busy variable of the APP handle structure. Based on the UI configuration, either standard receive
 * buffer or receive FIFO is used for data reception. An interrupt is configured for received data from the bus. This function
 * only registers a request to receive a number of data bytes from a SPI channel. If FIFO is configured for reception,
 * the FIFO limit is dynamically configured to optimally utilize the CPU load.
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t ReadData[10];
 *   uint8_t SendData[10] = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA};
 *
 *   status =  DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transfer(&SPI_MASTER_0, SendData, ReadData, 10);
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
SPI_MASTER_STATUS_t SPI_MASTER_Transfer(const SPI_MASTER_t *const handle,
                                        uint8_t* tx_dataptr,
                                        uint8_t* rx_dataptr,
                                        uint32_t count);
/**
 * @brief Receives the specified number of data words and execute the callback defined in GUI, if enabled.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param dataptr Pointer to data in which value is written
 * @param count number of data words (word length configured) to be read
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS : if read is successful\n
 *          SPI_MASTER_STATUS_FAILURE : if read is failed
 * <BR>
 * \par<b>Description:</b><br>
 * After receiving the specified number of words (word length configured), the user configured callback function
 * is executed, if it is enabled. If a callback function is not configured on the APP UI, the user has to poll for
 * the status of rx_busy variable of the APP handle structure. Based on the UI configuration, either standard receive
 * buffer or receive FIFO is used for data reception. An interrupt is configured for received data from the bus. This
 * function only registers a request to receive a number of data bytes from a SPI channel. If FIFO is configured for
 * reception, the FIFO limit is dynamically configured to optimally utilize the CPU load.
 * <a href="..\group___architecture___description.html#spi_master_receive_flow_chart">Click here for Flowchart.</a>
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t ReadData[10];
 *
 *   status =  DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(SPI_MASTER_Receive(&SPI_MASTER_0, ReadData, 10U))
 *     {
 *       while(SPI_MASTER_0.runtime->rx_busy)
 *       {
 *       }
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, ReadData, 10U);
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
SPI_MASTER_STATUS_t SPI_MASTER_Receive(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count);

/**
 * @brief Transmits the specified number of data words and execute the callback defined in GUI, if enabled.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param dataptr Pointer to data
 * @param count number of data words (word length configured) to be transmitted
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS : if transmit is successful\n
 *          SPI_MASTER_STATUS_FAILURE : if transmit is failed
 * <BR>
 *
 * \par<b>Description:</b><br>
 * The data transmission is accomplished using transmit interrupt. After transmitting the total data, the callback
 * function is executed. If transmit FIFO is enabled, the trigger limit is set to 1. So the transmit interrupt is
 * generated when all the data in FIFO is moved from FIFO. The function uses APP handle's dynamic structure to store
 * the data pointer, count, data index and status of transmission. This function only registers a data transmission
 * request if there is no active transmission in progress. Actual data transmission happens in the transmit interrupt
 * service routine. A trigger is generated for the transmit interrupt to start loading the data. If transmit FIFO is
 * configured, the data is filled into the FIFO with trigger limit set to 1. Transmit interrupt will be generated again
 * when the transmit FIFO is empty. At this point of time, if there is some more data to be transmitted, it is loaded
 * to the FIFO again. When FIFO is not enabled, data is transmitted one byte at a time. On transmission of each byte
 * an interrupt is generated and the next byte is transmitted in the interrupt service routine.
 * <a href="..\group___architecture___description.html#spi_master_transmit_flow_chart">Click here for Flowchart.</a>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data)) == SPI_MASTER_STATUS_SUCCESS)
 *     {
 *       while(SPI_MASTER_0.runtime->tx_busy)
 *       {
 *       }
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR> </p>
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_Transmit(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count);

/**
 * @brief Returns the state of the specified interrupt flag.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param flag Interrupt for which status is required
 *             Use type @ref XMC_SPI_CH_STATUS_FLAG_t for the bitmask of events.
 * @return  uint32_t status of the interrupt
 * <BR>
 *
 * \par<b>Description:</b><br>
 * Returns the status of the events, by reading PSR register. This indicates the status of the all the events, for
 * SPI communication.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     while(SPI_MASTER_GetFlagStatus(&SPI_MASTER_0, XMC_SPI_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION));
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 *
 */

__STATIC_INLINE uint32_t SPI_MASTER_GetFlagStatus(const SPI_MASTER_t* handle, const uint32_t flag)
{
  XMC_ASSERT("SPI_MASTER_GetFlagStatus:handle NULL" , (handle != NULL));
  return (XMC_SPI_CH_GetStatusFlag(handle->channel) & flag);
}

/**
 * @brief Clears the status of the specified interrupt flags.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param flag_mask Interrupt for which status has to be cleared
 *             Use type @ref XMC_SPI_CH_STATUS_FLAG_t for the bitmask of events.
 * <BR>
 * \par<b>Description:</b><br>
 * During communication the events occurred has to be cleared to get the successive events.\n
 * e.g: During transmission Transmit buffer event occurs to indicating data word transfer has started. This event has
 * to be cleared after transmission of each data word. Otherwise next event is not considered as valid.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     while(SPI_MASTER_GetFlagStatus(&SPI_MASTER_0, (uint32_t)XMC_SPI_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION));
 *     SPI_MASTER_ClearFlag(&SPI_MASTER_0, (uint32_t)XMC_SPI_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION);
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
__STATIC_INLINE void SPI_MASTER_ClearFlag(const SPI_MASTER_t* handle, const uint32_t flag_mask)
{
    XMC_ASSERT("SPI_MASTER_ClearFlag:handle NULL" , (handle != NULL));
    XMC_SPI_CH_ClearStatusFlag(handle->channel, flag_mask);
}

/**
 * @brief Enables the specified slave select line
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param slave which slave signal has to be enabled
 * <BR>
 * \par<b>Description:</b><br>
 * Each slave is connected with one slave select signal. At a time only one slave can be communicate. Enable the
 * required slave to start the communication.
 * <BR>
 *
 * Example Usage:
 * Generate code for multiple slave by configuring in "Advanced settings tab". Transmit the data to the required slave.
 * @code
 *
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     SPI_MASTER_DisableSlaveSelectSignal(&SPI_MASTER_0);
 *     SPI_MASTER_EnableSlaveSelectSignal(&SPI_MASTER_0, SPI_MASTER_0.config->slave_select_pin_config[1]->slave_select_ch);
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *   }
 *
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 *
 */
__STATIC_INLINE void SPI_MASTER_EnableSlaveSelectSignal(const SPI_MASTER_t* handle, const SPI_MASTER_SS_SIGNAL_t slave)
{
    XMC_ASSERT("SPI_MASTER_EnableSlaveSelectSignal:handle NULL" , (handle != NULL));
    XMC_ASSERT("SPI_MASTER_EnableSlaveSelectSignal:Invalid Slave selection" , ((slave == SPI_MASTER_SS_SIGNAL_0) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_1) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_2) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_3) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_4) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_5) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_6) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_7))
                                                                              );
    XMC_SPI_CH_EnableSlaveSelect(handle->channel, handle->config->slave_select_pin_config[slave]->slave_select_ch);
}

/**
 * @brief Disables the all the slave select lines
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * <BR>
 * \par<b>Description:</b><br>
 * Disable all the slave signals by clearing PCR.SELO bits.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     SPI_MASTER_DisableSlaveSelectSignal(&SPI_MASTER_0);
 *     SPI_MASTER_EnableSlaveSelectSignal(&SPI_MASTER_0, SPI_MASTER_0.config->slave_select_pin_config[1]->slave_select_ch);
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *   }
 *
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 *
 */
__STATIC_INLINE void SPI_MASTER_DisableSlaveSelectSignal(const SPI_MASTER_t* handle)
{
    XMC_ASSERT("SPI_MASTER_Transmit:handle NULL" , (handle != NULL));
    XMC_SPI_CH_DisableSlaveSelect(handle->channel);
}

/**
 * @brief Aborts the ongoing data transmission.
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return None
 *
 * \par<b>Description:</b><br>
 * If there is a transmission in progress, it will be stopped. If transmit FIFO is used,
 * the existing data will be flushed. After the transmission is stopped, user can start
 * a new transmission without delay.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *   uint8_t NewData[] = "New data message";
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *
 *     if(SPI_MASTER_0.runtime->tx_busy)
 *     {
 *       SPI_MASTER_AbortTransmit(&SPI_MASTER_0);
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, NewData, sizeof(NewData));
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_AbortTransmit(const SPI_MASTER_t *const handle);

/**
 * @brief Stops the active data reception request.
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return None
 * <BR>
 * \par<b>Description:</b><br>
 * If a reception is in progress, it will be stopped. When a reception request
 * is active, user will not be able to place a new receive request till the active
 * reception is complete. This API can stop the progressing reception to make
 * a new receive request.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *   uint8_t Rec_Data[64];
 *
 *   status = DAVE_Init();	// SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     while(SPI_MASTER_0.runtime->tx_busy);
 *
 *     SPI_MASTER_Receive(&SPI_MASTER_0, Rec_Data, 15);
 *
 *     while(SPI_MASTER_0.runtime->rx_data_index == 0);
 *     if(SPI_MASTER_0.runtime->rx_data[0] == 0x55)
 *     {
 *       SPI_MASTER_AbortReceive(&SPI_MASTER_0);
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, Rec_Data, 1);
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_AbortReceive(const SPI_MASTER_t *const handle);

/**
 *@}
 */
#include "spi_master_extern.h"

#ifdef __cplusplus
}
#endif

#endif /* SPI_MASTER_H */
