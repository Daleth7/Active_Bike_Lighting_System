/**
 * @file spi_master.c
 * @date 2015-07-07
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * SPI_MASTER v4.2.6 - Configures the properties of USIC channel to support SPI mode of communication.
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version<br>
 *
 * 2015-02-20:
 *     - SPI_MASTER_SetMode() API is updated to return, error if mode change is not possible.<br>
 *
 * 2015-05-08:
 *     - SPI_MASTER_SetBaudRate() and SPI_MASTER_Transfer() are added<br>
 *     - "SPI_MASTER_OVERSAMPLING" macro is removed, since it is not being used<br>
 *     - SPI_MASTER_lInit() prototype is moved to spi_master_conf.c file<br>
 *     - All local APIs are made as static<br>
 *     - Added SPI_MASTER_lPortModeSet() and SPI_MASTER_lPortModeReset() to support SPI_MASTER_SetBaudRate() API<br>
 *     - SPI_MASTER_lStd_RBUF_Flush() renamed as SPI_MASTER_lStd_RBUFFlush()<br>
 *     - SPI_MASTER_lGetFIFOSize() is removed by replacing the functionality<br>
 *     - In SPI_MASTER_Receive(), SPI_MASTER_Transmit() APIs a runtime condition check is added for null data pointer
 *       and length<br>
 *     - In SPI_MASTER_lTransmitHandler() API, local call to FIFO fill is removed and replaced with code<br>
 *
 * 2015-06-20:
 *     - For SPI_MASTER_Transfer(), SPI_MASTER_Receive(), SPI_MASTER_Transmit() APIs, the input data pointer is changed
 *       from 16-bit to 8-bit.
 *     - Word count in Transmission and reception APIs, is updated according to the word length set,
 *       instead of data length.
 *     - In SPI_MASTER_Transfer() API, a check is added to support full duplex mode only.
 *     - SPI_MASTER_lFIFORead() local API signature is changed to accept number of bytes per word.
 *     - word_length is moved from SPI_MASTER_CONFIG_t to SPI_MASTER_DYNAMIC_CONFIG_t, to support runtime change.
 *     - Abort API are updated to return the status.
 *
 * 2015-07-07:
 *     - DYNAMIC_CONFIG_t is renamed as RUNTIME_t
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "spi_master.h"


/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#if (UC_FAMILY == XMC4)
#define SPI_MASTER_CPU_CTRL_Init CPU_CTRL_XMC4_Init
#else
#define SPI_MASTER_CPU_CTRL_Init CPU_CTRL_XMC1_Init
#endif

#define SPI_MASTER_WORD_LENGTH_8_BIT   (8U) /* This is used to check while incrementing the data index */
#define SPI_MASTER_2_BYTES_PER_WORD    (2U) /* Word length is 16-bits */
#define SPI_MASTER_1_BYTE_PER_WORD     (1U) /* Word length is 8-bits */

/***********************************************************************************************************************
 * LOCAL DATA
***********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
/* This is used to reconfigure the registers while changing the SPI mode dynamically */
static void SPI_MASTER_lPortConfig(const SPI_MASTER_t* handle);
/* This is used to reconfigure the FIFO settings dynamically */
static void SPI_MASTER_lReconfigureRxFIFO(const SPI_MASTER_t * const handle, uint32_t data_size);
/* Flush RBUF0, RBUF1 */
static void SPI_MASTER_lStdRBUFFlush(XMC_USIC_CH_t *const channel);
/* Read data from FIFO */
static void SPI_MASTER_lFIFORead(const SPI_MASTER_t * const handle, const uint32_t bytes_per_word);
/* Set the mode of the port pin according to the configuration */
static void SPI_MASTER_lPortModeSet(const SPI_MASTER_t* handle);
/* Set the mode of the port pin as input */
static void SPI_MASTER_lPortModeReset(const SPI_MASTER_t* handle);
/* Receive interrupt handler for the app */
void SPI_MASTER_lReceiveHandler(const SPI_MASTER_t * const handle);
/* Transmit interrupt handler for the app */
void SPI_MASTER_lTransmitHandler(const SPI_MASTER_t * const handle);
#ifdef SPI_MASTER_PARITY_ERROR
/* Protocol interrupt handler for the app */
void SPI_MASTER_lProtocolHandler(const SPI_MASTER_t * const handle);
#endif

/***********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
/*
 * API to retrieve the version of the SPI_MASTER
 */
DAVE_APP_VERSION_t SPI_MASTER_GetAppVersion()
{
  DAVE_APP_VERSION_t version;

  version.major = SPI_MASTER_MAJOR_VERSION;
  version.minor = SPI_MASTER_MINOR_VERSION;
  version.patch = SPI_MASTER_PATCH_VERSION;

  return version;
}

/*
 * This function initializes the SPI channel, based on UI configuration.
 */
SPI_MASTER_STATUS_t SPI_MASTER_Init(SPI_MASTER_t* const handle)
{
  SPI_MASTER_STATUS_t status;

  XMC_ASSERT("SPI_MASTER_Init:handle NULL" , (handle != NULL));

  /* Initialize the CPU APP */
  status = (SPI_MASTER_STATUS_t)SPI_MASTER_CPU_CTRL_Init(CPU_CTRL_HANDLE);

  if (SPI_MASTER_STATUS_SUCCESS == status)
  {
    /* Configure the port registers and data input registers of SPI channel */
    handle->config->fptr_spi_master_config();

    status = SPI_MASTER_STATUS_SUCCESS;
  }

  return (status);
}

/*
 * Change the SPI mode of communication.
 */
SPI_MASTER_STATUS_t SPI_MASTER_SetMode(SPI_MASTER_t* const handle,
                                       const XMC_SPI_CH_MODE_t mode)
{
  SPI_MASTER_STATUS_t status;

  XMC_ASSERT("SPI_MASTER_Configure:handle NULL" , (handle != NULL));

  status = SPI_MASTER_STATUS_FAILURE;

  if (handle->runtime->dx0_input != SPI_MASTER_INPUT_INVALID)
  {
    if ((false == handle->runtime->tx_busy) && (false == handle->runtime->rx_busy))
    {
      handle->runtime->spi_master_mode = mode;

      /* This changes the operating mode and related settings */
      SPI_MASTER_lPortConfig(handle);

      status = SPI_MASTER_STATUS_SUCCESS;
    }
    else
    {
      status = SPI_MASTER_STATUS_BUSY;
    }
  }

  return (status);
}

/*
 * Set the baud rate during runtime.
 */
SPI_MASTER_STATUS_t SPI_MASTER_SetBaudRate(SPI_MASTER_t* const handle, const uint32_t baud_rate)
{
  SPI_MASTER_STATUS_t status;

  if ((false == handle->runtime->tx_busy) && (false == handle->runtime->rx_busy))
  {
    /* Stops the SPI channel */
    status = (SPI_MASTER_STATUS_t)XMC_SPI_CH_Stop(handle->channel);

    if (SPI_MASTER_STATUS_SUCCESS == status)
    {
      /* Set all the pins as input */
      SPI_MASTER_lPortModeReset(handle);

      /* Update the new baud rate */
      status = (SPI_MASTER_STATUS_t)XMC_SPI_CH_SetBaudrate(handle->channel, baud_rate);

      if (SPI_MASTER_STATUS_SUCCESS == status)
      {
        /* Configure Leading/Trailing delay */
        XMC_SPI_CH_SetSlaveSelectDelay(handle->channel, (uint32_t)handle->config->leading_trailing_delay);
      }

      /* Configure the clock polarity and clock delay */
      XMC_SPI_CH_ConfigureShiftClockOutput(handle->channel,
                                           handle->config->shift_clk_passive_level,
                                           XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK);
      /* Start the SPI channel */
      XMC_SPI_CH_Start(handle->channel);

      /* Set the mode of the according the generated configuration */
      SPI_MASTER_lPortModeSet(handle);
    }
  }
  else
  {
    status = SPI_MASTER_STATUS_BUSY;
  }

  return status;
}

/*
 * Transmit and receive the data at the same time. This is supported for full duplex mode only.
 */
SPI_MASTER_STATUS_t SPI_MASTER_Transfer(const SPI_MASTER_t *const handle,
                                        uint8_t* tx_dataptr,
                                        uint8_t* rx_dataptr,
                                        uint32_t count)
{
  SPI_MASTER_STATUS_t status;
  uint32_t bytes_per_word; /* This is to support the word length 8 and 16. Specify the number
                              of bytes for the configured word length */
  SPI_MASTER_RUNTIME_t * runtime_handle;

  XMC_ASSERT("SPI_MASTER_Transfer:handle NULL" , (handle != NULL));

  status = SPI_MASTER_STATUS_BUSY;
  runtime_handle = handle->runtime;

  if (XMC_SPI_CH_MODE_STANDARD == runtime_handle->spi_master_mode)
  {
    /* Check whether SPI channel is free or not */
    if ((tx_dataptr != NULL) && (rx_dataptr != NULL) && (count > 0U))
    {
      /*Check data pointer is valid or not*/
      if ((false == runtime_handle->rx_busy) && (false == runtime_handle->tx_busy))
      {
	    if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
	    {
		  bytes_per_word = SPI_MASTER_2_BYTES_PER_WORD; /* Word length is 16-bits */
	    }
	    else
	    {
		  bytes_per_word = SPI_MASTER_1_BYTE_PER_WORD; /* Word length is 8-bits */
	    }
        /* If no active reception in progress, obtain the address of data buffer and number of data bytes to be received */
        runtime_handle->rx_data = rx_dataptr;
        runtime_handle->rx_data_count = (uint32_t)count << (bytes_per_word - 1U);
        runtime_handle->rx_busy = true;
        runtime_handle->rx_data_index = 0U;
        runtime_handle->tx_data_dummy = false;

        /* Check if FIFO is enabled */
        if ((uint32_t)handle->config->rx_fifo_size > 0U)
        {
          /* Clear the receive FIFO */
          XMC_USIC_CH_RXFIFO_Flush(handle->channel);

          /* Configure the FIFO trigger limit based on the required data size */
          SPI_MASTER_lReconfigureRxFIFO(handle, count);

          /* Enable the receive FIFO events */
          XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel,(uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD | \
                                                                    (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        }
        else
        {
          /* Flush the RBUF0 and RBUF1 */
          SPI_MASTER_lStdRBUFFlush(handle->channel);

          /* Enable the standard receive events */
          XMC_USIC_CH_EnableEvent(handle->channel,
            (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
        }
        /* Call the transmit, to receive the data synchronously */
        status = SPI_MASTER_Transmit(handle, tx_dataptr, count);
      }
    }
    else
    {
      status = SPI_MASTER_STATUS_BUFFER_INVALID;
    }
  }
  else
  {
	status = SPI_MASTER_STATUS_FAILURE;
  }

  return status;
}

/*
 * Receive the specified the number of data words.
 */
SPI_MASTER_STATUS_t SPI_MASTER_Receive(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count)
{
  SPI_MASTER_STATUS_t status;
  uint32_t bytes_per_word; /* This is to support the word length 8 and 16. Specify the number
                               of bytes for the configured word length */
  SPI_MASTER_RUNTIME_t * runtime_handle;

  XMC_ASSERT("SPI_MASTER_Receive:handle NULL" , (handle != NULL));

  status = SPI_MASTER_STATUS_BUSY;
  runtime_handle = handle->runtime;

  /* Check whether SPI channel is free or not */
  if ((dataptr != NULL) && (count > 0U))
  {
    /*Check data pointer is valid or not*/
    if ((false == runtime_handle->rx_busy) && (false == runtime_handle->tx_busy))
    {
	  if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
	  {
	    bytes_per_word = SPI_MASTER_2_BYTES_PER_WORD; /* Word length is 16-bits */
	  }
	  else
	  {
	    bytes_per_word = SPI_MASTER_1_BYTE_PER_WORD; /* Word length is 8-bits */
	  }
      /* If no active reception in progress, obtain the address of data buffer and number of data bytes to be received */
      runtime_handle->rx_data = dataptr;
      runtime_handle->rx_data_count = (uint32_t)count << (bytes_per_word - 1U);
      runtime_handle->rx_busy = true;
      runtime_handle->rx_data_index = 0U;
      runtime_handle->tx_data_dummy = true;

      /* Check if FIFO is enabled */
      if ((uint32_t)handle->config->rx_fifo_size > 0U)
      {
        /* Clear the receive FIFO */
        XMC_USIC_CH_RXFIFO_Flush(handle->channel);

        /* Configure the FIFO trigger limit based on the required data size */
        SPI_MASTER_lReconfigureRxFIFO(handle, count);

        /* Enable the receive FIFO events */
        XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel,(uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD | \
                                                                  (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
      }
      else
      {
        /* Flush the RBUF0 and RBUF1 */
        SPI_MASTER_lStdRBUFFlush(handle->channel);

        /* Enable the standard receive events */
        XMC_USIC_CH_EnableEvent(handle->channel,
            (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
      }
      /* Call the transmit, to receive the data synchronously */
      status = SPI_MASTER_Transmit(handle, dataptr, count);
    }
  }
  else
  {
    status = SPI_MASTER_STATUS_BUFFER_INVALID;
  }
  return status;
}

/*
 * Transmit the number of data words specified.
 */
SPI_MASTER_STATUS_t SPI_MASTER_Transmit(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count)
{
  SPI_MASTER_STATUS_t status;
  uint32_t bytes_per_word; /* This is to support the word length 8 and 16. Specify the number
                               of bytes for the configured word length */
  SPI_MASTER_RUNTIME_t * runtime_handle;

  XMC_ASSERT("SPI_MASTER_Transmit:handle NULL" , (handle != NULL));

  status = SPI_MASTER_STATUS_BUSY;
  runtime_handle = handle->runtime;

  /* Check whether SPI channel is free or not */
  if ((dataptr != NULL) && (count > 0U))
  {
    /*Check data pointer is valid or not*/
    if (false == runtime_handle->tx_busy)
    {
	  if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
	  {
	    bytes_per_word = SPI_MASTER_2_BYTES_PER_WORD; /* Word length is 16-bits */
	  }
	  else
	  {
	    bytes_per_word = SPI_MASTER_1_BYTE_PER_WORD; /* Word length is 8-bits */
	  }
      /* Obtain the address of data, size of data */
      runtime_handle->tx_data = dataptr;
      runtime_handle->tx_data_count = (uint32_t)count << (bytes_per_word - 1U);
      /* Initialize to first index and set the busy flag */
      runtime_handle->tx_data_index = 0U;
      runtime_handle->tx_busy = true;

      /* Enable the transmit buffer event */
      if ((uint32_t)handle->config->tx_fifo_size > 0U)
      {
        /* Flush the Transmit FIFO */
        XMC_USIC_CH_TXFIFO_Flush(handle->channel);
        XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
      }
      else
      {
        XMC_USIC_CH_EnableEvent(handle->channel,(uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
      }

      status = SPI_MASTER_STATUS_SUCCESS;

      /* Trigger the transmit buffer interrupt */
      XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)handle->config->tx_sr);
    }
  }
  else
  {
    status = SPI_MASTER_STATUS_BUFFER_INVALID;
  }
  return status;
}

/*
 * Aborts the ongoing data reception.
 */
SPI_MASTER_STATUS_t SPI_MASTER_AbortReceive(const SPI_MASTER_t *const handle)
{
  SPI_MASTER_STATUS_t status;

  status = SPI_MASTER_STATUS_FAILURE;

  if (handle->runtime->rx_busy)
  {
    /* Abort if any ongoing transmission w.r.t reception. */
	status = SPI_MASTER_AbortTransmit(handle);

    if (status == SPI_MASTER_STATUS_SUCCESS)
    {
      /* Reset the user buffer pointer to null */
      handle->runtime->rx_busy = false;
      handle->runtime->rx_data = NULL;
      handle->runtime->tx_data_dummy = false;
      /* Disable the receive interrupts */
      if ((uint32_t)handle->config->rx_fifo_size > 0U)
      {
        XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,(uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD | \
                                                                 (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
      }
      else
      {
        XMC_SPI_CH_DisableEvent(handle->channel,
            (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
      }
      status = SPI_MASTER_STATUS_SUCCESS;
    }
    else
    {
      status = SPI_MASTER_STATUS_FAILURE;
    }
  }
  return status;
}

/*
 * Aborts the ongoing data transmission.
 */
SPI_MASTER_STATUS_t SPI_MASTER_AbortTransmit(const SPI_MASTER_t *const handle)
{
  SPI_MASTER_STATUS_t status;

  status = SPI_MASTER_STATUS_FAILURE;

  if (handle->runtime->tx_busy)
  {
    /*Reset the user buffer pointer to null*/
    handle->runtime->tx_busy = false;
    handle->runtime->tx_data = NULL;
    handle->runtime->tx_data_dummy = false;
    /*Disable the transmit interrupts*/
    if ((uint32_t)handle->config->tx_fifo_size > 0U)
    {
      /*Disable the transmit FIFO event*/
      XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
      XMC_USIC_CH_TXFIFO_Flush(handle->channel);
    }
    else
    {
      /*Disable the standard transmit event*/
      XMC_SPI_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
    }
    status = SPI_MASTER_STATUS_SUCCESS;
  }
  return status;
}
/***********************************************************************************************************************
**                                                Private API definitions                                             **
***********************************************************************************************************************/
/*
 * Read the data from FIFO until it becomes empty.
 */
void SPI_MASTER_lFIFORead(const SPI_MASTER_t * const handle, uint32_t bytes_per_word)
{
  SPI_MASTER_RUNTIME_t * runtime_handle;
  uint16_t data;

  runtime_handle = handle->runtime;
  data = 0U;

  /* When Receive FIFO is enabled*/
  while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
  {
    if (runtime_handle->rx_data_index < runtime_handle->rx_data_count)
    {
      data = XMC_SPI_CH_GetReceivedData(handle->channel);
	  memcpy((void *)&runtime_handle->rx_data[runtime_handle->rx_data_index], (void *)&data, bytes_per_word);
	  (runtime_handle->rx_data_index)+= bytes_per_word;
    }

    if (runtime_handle->rx_data_index == runtime_handle->rx_data_count)
    {
      /*Reception complete*/
      runtime_handle->rx_busy = false;
      runtime_handle->tx_data_dummy = false;
      /*Disable both standard receive and alternative receive FIFO events*/
      XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,(uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD | \
                                                                 (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
      if (handle->config->rx_cbhandler != NULL)
      {
        /* Execute the 'End of reception' callback function */
        handle->config->rx_cbhandler();
      }
      break;
    }
  }
}

/*
 * Transmit interrupt handler for the app.
 * This is a common interrupt handling function called for different instances of the app.
 */
void SPI_MASTER_lTransmitHandler(const SPI_MASTER_t * const handle)
{
  uint16_t data; /* Data to be loaded into the TBUF */
  uint32_t bytes_per_word; /* This is to support the word length 8 and 16. Specify the number
                              of bytes for the configured word length */
  SPI_MASTER_RUNTIME_t * runtime_handle = handle->runtime;

  if (runtime_handle->tx_data_index < runtime_handle->tx_data_count)
  {
	if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
	{
	  bytes_per_word = SPI_MASTER_2_BYTES_PER_WORD; /* Word length is 16-bits */
	}
	else
	{
	  bytes_per_word = SPI_MASTER_1_BYTE_PER_WORD; /* Word length is 8-bits */
	}
    data = 0U;
    /*When Transmit FIFO is enabled*/
    if ((uint32_t)handle->config->tx_fifo_size > 0U)
    {
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
      {
        if (runtime_handle->tx_data_index < runtime_handle->tx_data_count)
        {
          /*Load the FIFO byte by byte till either FIFO is full or all data is loaded*/
          if (runtime_handle->tx_data_dummy == true)
          {
            XMC_SPI_CH_Receive(handle->channel, runtime_handle->spi_master_mode);
            (runtime_handle->tx_data_index)+= bytes_per_word;
          }
          else
          {
		    memcpy((void *)&data, (void *)&runtime_handle->tx_data[runtime_handle->tx_data_index], bytes_per_word);
			(runtime_handle->tx_data_index)+= bytes_per_word;
			XMC_SPI_CH_Transmit(handle->channel, data, runtime_handle->spi_master_mode);
          }
        }
        else
        {
          break;
        }
      }
    }
    else/*When Transmit FIFO is disabled*/
    {
	  if (runtime_handle->tx_data_dummy == true)
	  {
		XMC_SPI_CH_Receive(handle->channel, runtime_handle->spi_master_mode);
		(runtime_handle->tx_data_index)+= bytes_per_word;
	  }
	  else
	  {
		memcpy((void *)&data, (void *)&runtime_handle->tx_data[runtime_handle->tx_data_index], bytes_per_word);
		(runtime_handle->tx_data_index)+=bytes_per_word;
		XMC_SPI_CH_Transmit(handle->channel, data, runtime_handle->spi_master_mode);
	  }
    }
  }
  else
  {
   if (XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == true)
   {
    /*Clear the flag*/
    if ((uint32_t)handle->config->tx_fifo_size > 0U)
    {
      /*Clear the transmit FIFO event*/
      XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
    }
    else
    {
      /*Clear the standard transmit event*/
      XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
    }

    /*Wait for the transmit buffer to be free to ensure that all data is transmitted*/
    while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
    {

    }

    /*All data is transmitted*/
    runtime_handle->tx_busy = false;
    runtime_handle->tx_data = NULL;

    if ((handle->config->tx_cbhandler != NULL) && (runtime_handle->rx_busy == false))
    {
      /*Execute the callback function provided in the SPI_MASTER app UI*/
      handle->config->tx_cbhandler();
    }
   }
  }
}

/*
 * Receive interrupt handler for the app.
 * This is a common interrupt handling function for different instances of the SPI_MASTER app.
 */
void SPI_MASTER_lReceiveHandler(const SPI_MASTER_t * const handle)
{
  uint16_t data; /* Data to be loaded into the TBUF */
  uint32_t bytes_per_word; /* This is to support the word length 8 and 16. Specify the number
                               of bytes for the configured word length */
  SPI_MASTER_RUNTIME_t * runtime_handle;

  runtime_handle = handle->runtime;
  data = 0U;

  if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
  {
	  bytes_per_word = SPI_MASTER_2_BYTES_PER_WORD; /* Word length is 16-bits */
  }
  else
  {
	  bytes_per_word = SPI_MASTER_1_BYTE_PER_WORD; /* Word length is 8-bits */
  }

  if ((uint32_t)handle->config->rx_fifo_size > 0U)
  {
    /* read the FIFO */
    SPI_MASTER_lFIFORead(handle, bytes_per_word);
    /*Set the trigger limit if data still to be received*/
    if (runtime_handle->rx_data_index < runtime_handle->rx_data_count)
    {
      SPI_MASTER_lReconfigureRxFIFO(handle, \
                               (uint32_t)(runtime_handle->rx_data_count - runtime_handle->rx_data_index));
    }
  }
  else
  {
    /* When RxFIFO is disabled */
    if ((XMC_USIC_CH_GetReceiveBufferStatus(handle->channel) & (uint32_t)XMC_USIC_CH_RBUF_STATUS_DATA_VALID0) != 0U )
    {
      if (runtime_handle->rx_data_index < runtime_handle->rx_data_count)
      {
    	data = XMC_SPI_CH_GetReceivedData(handle->channel);
		memcpy((void *)&runtime_handle->rx_data[runtime_handle->rx_data_index], (void *)&data, bytes_per_word);
		(runtime_handle->rx_data_index)+= bytes_per_word;

      }
    }
    if ((XMC_USIC_CH_GetReceiveBufferStatus(handle->channel) & (uint32_t)XMC_USIC_CH_RBUF_STATUS_DATA_VALID1) != 0U)
    {
	  if (runtime_handle->rx_data_index < runtime_handle->rx_data_count)
	  {
	    data = XMC_SPI_CH_GetReceivedData(handle->channel);
		memcpy((void *)&runtime_handle->rx_data[runtime_handle->rx_data_index], (void *)&data, bytes_per_word);
		(runtime_handle->rx_data_index)+= bytes_per_word;
      }
    }

    if (runtime_handle->rx_data_index == runtime_handle->rx_data_count)
    {
      /* Disable both standard receive and alternative receive FIFO events */
      XMC_USIC_CH_DisableEvent(handle->channel,
          (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE));

      /* Reception complete */
      runtime_handle->rx_busy = false;
      runtime_handle->tx_data_dummy = false;
      runtime_handle->rx_data = NULL;

      if (handle->config->rx_cbhandler != NULL)
      {
        /* Execute the 'End of reception' callback function */
        handle->config->rx_cbhandler();
      }
    }
  }
}

#ifdef SPI_MASTER_PARITY_ERROR
/*
 * Protocol interrupt handling function.
 * The function is common for different instances of the SPI_MASTER app.
 */
void SPI_MASTER_lProtocolHandler(const SPI_MASTER_t * const handle)
{
  uint32_t psr_status;

  psr_status = XMC_SPI_CH_GetStatusFlag(handle->channel);

  /* Check for Parity detection error */
  if ((handle->config->parity_cbhandler != NULL) && \
                                           (psr_status & (uint32_t)XMC_SPI_CH_STATUS_FLAG_PARITY_ERROR_EVENT_DETECTED))
  {
    handle->config->parity_cbhandler();
  }
}
#endif

/*
 * This function configures the FIFO settings
 */
static void SPI_MASTER_lReconfigureRxFIFO(const SPI_MASTER_t * const handle, uint32_t data_size)
{
  uint32_t fifo_size;
  uint32_t ret_limit_val;

  if (((uint32_t)handle->config->rx_fifo_size > 0U) && (data_size > 0U))
  {
    fifo_size = (uint32_t)0x01 << handle->config->rx_fifo_size;

    if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
    {
    	/* Data size is divided by 2, to change the trigger limit according the word length */
    	data_size = (uint32_t)data_size >> 1U;
    }

    /*If data size is more than FIFO size, configure the limit to the FIFO size*/
    if (data_size < fifo_size)
    {
      ret_limit_val = data_size - 1U;
    }
    else
    {
      ret_limit_val = fifo_size - 1U;
    }

    /*Set the limit value*/
    XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->rx_fifo_size, ret_limit_val);
  }
}

/*
 * Clears the receive buffers
 */
static void SPI_MASTER_lStdRBUFFlush(XMC_USIC_CH_t *const channel)
{
  /* Clear RBF0 */
  (void)XMC_SPI_CH_GetReceivedData(channel);
  /* Clear RBF1 */
  (void)XMC_SPI_CH_GetReceivedData(channel);
}

/*
 * This is used to reconfigure the registers while changing the SPI mode dynamically
 */
static void SPI_MASTER_lPortConfig(const SPI_MASTER_t* handle)
{
  switch (handle->runtime->spi_master_mode)
  {
    case XMC_SPI_CH_MODE_STANDARD:
      /* Configure the data input line selected */
      XMC_SPI_CH_SetInputSource(handle->channel, XMC_SPI_CH_INPUT_DIN0, (uint8_t)(handle->runtime->dx0_input));
      /* Configure the pin as input */
      XMC_GPIO_SetMode(handle->config->mosi_1_pin->port, handle->config->mosi_1_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
      /* Disable the HW control of the PINs */
      XMC_GPIO_SetHardwareControl(handle->config->mosi_0_pin->port,
                                  handle->config->mosi_0_pin->pin,
                                  XMC_GPIO_HWCTRL_DISABLED);
      XMC_GPIO_SetHardwareControl(handle->config->mosi_1_pin->port,
                                  handle->config->mosi_1_pin->pin,
                                  XMC_GPIO_HWCTRL_DISABLED);

      break;

    case XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX:
      /* Configure the data input line selected */
      XMC_SPI_CH_SetInputSource(handle->channel, XMC_SPI_CH_INPUT_DIN0, (uint8_t)(handle->runtime->dx0_input));
      /* Disable the HW control of the PINs */
      XMC_GPIO_SetHardwareControl(handle->config->mosi_0_pin->port,
                                  handle->config->mosi_0_pin->pin,
                                  XMC_GPIO_HWCTRL_DISABLED);
      break;

    case XMC_SPI_CH_MODE_DUAL:
    case XMC_SPI_CH_MODE_QUAD:
      /* Configure the data input line for loopback mode */
      XMC_SPI_CH_SetInputSource(handle->channel, XMC_SPI_CH_INPUT_DIN0, (uint8_t)SPI_MASTER_INPUT_G);
      /* Configure the pin as input */
      XMC_GPIO_SetMode(handle->config->mosi_1_pin->port,
                       handle->config->mosi_1_pin->pin,
                       handle->config->mosi_1_pin_config->port_config.mode);

      /* Configure the Hardware control mode selected for the pin */
      XMC_GPIO_SetHardwareControl(handle->config->mosi_0_pin->port,
                                  handle->config->mosi_0_pin->pin,
                                  handle->config->mosi_0_pin_config->hw_control);
      XMC_GPIO_SetHardwareControl(handle->config->mosi_1_pin->port,
                                  handle->config->mosi_1_pin->pin,
                                  handle->config->mosi_1_pin_config->hw_control);
      break;

    default:
      break;
  }
}

/*
 * This is used to reassign the mode for ports after updating the baud rate
 */
static void SPI_MASTER_lPortModeSet(const SPI_MASTER_t* handle)
{
  uint32_t ss_line;

  /* Configure the ports with actual mode */
  for (ss_line = 0U; ss_line < handle->config->slave_select_lines; ss_line++)
  {
    XMC_GPIO_SetMode(handle->config->slave_select_pin[ss_line]->port,
                     handle->config->slave_select_pin[ss_line]->pin,
                     handle->config->slave_select_pin_config[ss_line]->port_config.mode);
  }

  XMC_GPIO_SetMode(handle->config->sclk_out_pin->port,
                   handle->config->sclk_out_pin->pin,
                   handle->config->sclk_out_pin_config->port_config.mode);

  switch (handle->runtime->spi_master_mode)
  {
    case XMC_SPI_CH_MODE_STANDARD:
    case XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX:
      XMC_GPIO_SetMode(handle->config->mosi_0_pin->port,
                       handle->config->mosi_0_pin->pin,
                       handle->config->mosi_0_pin_config->port_config.mode);
      break;

    case XMC_SPI_CH_MODE_DUAL:
      XMC_GPIO_SetMode(handle->config->mosi_0_pin->port,
                       handle->config->mosi_0_pin->pin,
                       handle->config->mosi_0_pin_config->port_config.mode);
      XMC_GPIO_SetMode(handle->config->mosi_1_pin->port,
                       handle->config->mosi_1_pin->pin,
                       handle->config->mosi_1_pin_config->port_config.mode);
      break;

    case XMC_SPI_CH_MODE_QUAD:
      XMC_GPIO_SetMode(handle->config->mosi_0_pin->port,
                       handle->config->mosi_0_pin->pin,
                       handle->config->mosi_0_pin_config->port_config.mode);
      XMC_GPIO_SetMode(handle->config->mosi_1_pin->port,
                       handle->config->mosi_1_pin->pin,
                       handle->config->mosi_1_pin_config->port_config.mode);
      XMC_GPIO_SetMode(handle->config->mosi_2_pin->port,
                       handle->config->mosi_2_pin->pin,
                       handle->config->mosi_2_pin_config->port_config.mode);
      XMC_GPIO_SetMode(handle->config->mosi_3_pin->port,
                       handle->config->mosi_3_pin->pin,
                       handle->config->mosi_3_pin_config->port_config.mode);
      break;

    default:
      break;
  }
}

/*
 * This is used to make the ports as input during update of the baud rate, to avoid the noise in output ports
 */
static void SPI_MASTER_lPortModeReset(const SPI_MASTER_t* handle)
{
  uint32_t ss_line;

  /* Configure the ports as input */
  for (ss_line = 0U; ss_line < handle->config->slave_select_lines; ss_line++)
  {
    XMC_GPIO_SetMode(handle->config->slave_select_pin[ss_line]->port,
                     handle->config->slave_select_pin[ss_line]->pin,
                     XMC_GPIO_MODE_INPUT_TRISTATE);
  }

  XMC_GPIO_SetMode(handle->config->sclk_out_pin->port, handle->config->sclk_out_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);

  switch (handle->runtime->spi_master_mode)
  {
    case XMC_SPI_CH_MODE_STANDARD:
    case XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX:
      XMC_GPIO_SetMode(handle->config->mosi_0_pin->port, handle->config->mosi_0_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
      break;

    case XMC_SPI_CH_MODE_DUAL:
      XMC_GPIO_SetMode(handle->config->mosi_0_pin->port, handle->config->mosi_0_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
      XMC_GPIO_SetMode(handle->config->mosi_1_pin->port, handle->config->mosi_1_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
      break;

    case XMC_SPI_CH_MODE_QUAD:
      XMC_GPIO_SetMode(handle->config->mosi_0_pin->port, handle->config->mosi_0_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
      XMC_GPIO_SetMode(handle->config->mosi_1_pin->port, handle->config->mosi_1_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
      XMC_GPIO_SetMode(handle->config->mosi_2_pin->port, handle->config->mosi_2_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
      XMC_GPIO_SetMode(handle->config->mosi_3_pin->port, handle->config->mosi_3_pin->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
      break;

    default:
      break;
  }
}

